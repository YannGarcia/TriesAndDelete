// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/4 R2A
// for Arpad Lovassy (earplov@esekilxxen1841) on Tue Jul 22 16:49:55 2014

// Copyright (c) 2000-2015 Ericsson Telecom AB

// You may modify this file. Complete the body of empty functions and// add your member functions here.

#include "PCOType.hh"
#include "memory.h"

//#include <stdio.h>
#include <iostream>

namespace MyExample {

PCOType::PCOType(const char *par_port_name)
: PCOType_BASE(par_port_name)
{
	log("PCOType: %s\n", par_port_name);

}

PCOType::~PCOType()
{
	log( "~PCOType\n");

}

void PCOType::set_parameter(const char * parameter_name, const char * parameter_value)
{
	if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_UNQUALIFIED)) TTCN_Logger::log(TTCN_Logger::DEBUG_UNQUALIFIED, "set_parameter: %s = %s\n", parameter_name, parameter_value);
}

void PCOType::Event_Handler(const fd_set *read_fds,
		const fd_set *write_fds, const fd_set *error_fds,
		double time_since_last_call)
{
	size_t buf_len = 0, buf_size = 32;
	char *buf = (char*)Malloc(buf_size);
	for ( ; ; ) {
		int c = getc(stdin);
		if (c == EOF) {
			if (buf_len > 0) incoming_message(CHARSTRING(buf_len, buf));
			Uninstall_Handler();
			break;
		} else if (c == '\n') {
			incoming_message(CHARSTRING(buf_len, buf));
			break;
		} else {
			if (buf_len >= buf_size) {
				buf_size *= 2;
				buf = (char*)Realloc(buf, buf_size);
			}
			buf[buf_len++] = c;
		}
	}
	Free(buf);
}

/*void PCOType::Handle_Fd_Event(int fd, boolean is_readable,
	boolean is_writable, boolean is_error) {}*/

void PCOType::Handle_Fd_Event_Error(int /*fd*/)
{

}

void PCOType::Handle_Fd_Event_Writable(int /*fd*/)
{

}

void PCOType::Handle_Fd_Event_Readable(int /*fd*/)
{

}

/*void PCOType::Handle_Timeout(double time_since_last_call) {}*/

void PCOType::user_map(const char *system_port)
{
	if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_UNQUALIFIED)) TTCN_Logger::log(TTCN_Logger::DEBUG_UNQUALIFIED, "user_map= %s\n", system_port);
	fd_set readfds;
	FD_ZERO(&readfds);
	FD_SET(fileno(stdin), &readfds);
	Install_Handler(&readfds, NULL, NULL, 0.0);
}

void PCOType::user_unmap(const char *system_port)
{
	if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_UNQUALIFIED)) TTCN_Logger::log(TTCN_Logger::DEBUG_UNQUALIFIED, "user_unmap= %s\n", system_port);
	Uninstall_Handler();
}

void PCOType::user_start()
{

}

void PCOType::user_stop()
{

}

void PCOType::outgoing_send(const CHARSTRING& send_par)
{
	if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_UNQUALIFIED)) TTCN_Logger::log(TTCN_Logger::DEBUG_UNQUALIFIED, "outgoing_send= %s\n", (const char *)send_par);
	puts((const char*)send_par);
	fflush(stdout);
	// Loopback
	incoming_message(CHARSTRING("Hello, TTCN-3!"));
}

void PCOType::outgoing_send(const UtInitialize& send_par)
{
	if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_UNQUALIFIED)) TTCN_Logger::log(TTCN_Logger::DEBUG_UNQUALIFIED, "outgoing_send= UtInitialize\n");
	send_par.log();
	BITSTRING encvalue = MyExample::fx__encvalue__UtInitialize(send_par);
	encvalue.log();
	puts((const char*)((const unsigned char *)encvalue));
	fflush(stdout);
	// Loopback
	const unsigned char result[2] = { 0x01, 0x01 };
	incoming_message(OCTETSTRING(2, (const unsigned char *)result));
}

void PCOType::log(const char *fmt, ...) {
	if (true) {
		va_list ap;
		va_start(ap, fmt);
		TTCN_Logger::begin_event(TTCN_DEBUG);
		TTCN_Logger::log_event("PCOType Test Port (%s): ", get_name());
		TTCN_Logger::log_event_va_list(fmt, ap);
		TTCN_Logger::end_event();
		va_end(ap);
	}
}

} /* end of namespace */
