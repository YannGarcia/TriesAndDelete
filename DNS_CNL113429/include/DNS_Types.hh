// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for Yann Garcia (yann@Ubuntu64) on Wed Feb 15 15:41:26 2017

// Copyright (c) 2000-2016 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef DNS__Types_HH
#define DNS__Types_HH

#ifndef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated with -R option but -DTITAN_RUNTIME_2 was not used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef DNS__Types_HH
#endif

namespace DNS__Types {

/* Forward declarations of classes */

class QueryOrResponse;
class QueryOrResponse_template;
class DnsHeader;
class DnsHeader_template;
class QResourceRecords;
class QResourceRecords_template;
class ResourceRecords;
class ResourceRecords_template;
class PDU__DNS;
class PDU__DNS_template;
class QResourceRecord;
class QResourceRecord_template;
class ResourceData;
class ResourceData_template;
class ResourceRecord;
class ResourceRecord_template;
class RDataHInfo;
class RDataHInfo_template;
class RDataMInfo;
class RDataMInfo_template;
class RDataMX;
class RDataMX_template;
class RDataSOA;
class RDataSOA_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING RDataTXT;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template RDataTXT_template;
class RDataWKS;
class RDataWKS_template;
class RDataSRV;
class RDataSRV_template;
class RDataNAPTR;
class RDataNAPTR_template;

} /* end of namespace */

#ifndef DNS__Types_HH
#define DNS__Types_HH

namespace DNS__Types {

/* Type definitions */

typedef INTEGER UInt16;
typedef INTEGER_template UInt16_template;
typedef INTEGER OpCode;
typedef INTEGER_template OpCode_template;
typedef INTEGER ResponseCode;
typedef INTEGER_template ResponseCode_template;
typedef CHARSTRING CharStr255;
typedef CHARSTRING_template CharStr255_template;
typedef CHARSTRING DomainName;
typedef CHARSTRING_template DomainName_template;
typedef INTEGER RRType;
typedef INTEGER_template RRType_template;
typedef INTEGER RRClass;
typedef INTEGER_template RRClass_template;
typedef OCTETSTRING UInt32;
typedef OCTETSTRING_template UInt32_template;
typedef CHARSTRING RDataCName;
typedef CHARSTRING_template RDataCName_template;
typedef CHARSTRING RDataMB;
typedef CHARSTRING_template RDataMB_template;
typedef CHARSTRING RDataMD;
typedef CHARSTRING_template RDataMD_template;
typedef CHARSTRING RDataMF;
typedef CHARSTRING_template RDataMF_template;
typedef CHARSTRING RDataMG;
typedef CHARSTRING_template RDataMG_template;
typedef CHARSTRING RDataMR;
typedef CHARSTRING_template RDataMR_template;
typedef OCTETSTRING RDataNull;
typedef OCTETSTRING_template RDataNull_template;
typedef CHARSTRING RDataNS;
typedef CHARSTRING_template RDataNS_template;
typedef CHARSTRING RDataPTR;
typedef CHARSTRING_template RDataPTR_template;
typedef OCTETSTRING RDataA;
typedef OCTETSTRING_template RDataA_template;
typedef OCTETSTRING RDataAAAA;
typedef OCTETSTRING_template RDataAAAA_template;
typedef INTEGER UInt8;
typedef INTEGER_template UInt8_template;

/* Class definitions */

class QueryOrResponse : public Enum_Type { // enum
friend class QueryOrResponse_template;
public:
enum enum_type { DNS__QUERY = 0, DNS__RESPONSE = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
QueryOrResponse();
QueryOrResponse(int other_value);
QueryOrResponse(enum_type other_value);
QueryOrResponse(const QueryOrResponse& other_value);

QueryOrResponse& operator=(int other_value);
QueryOrResponse& operator=(enum_type other_value);
QueryOrResponse& operator=(const QueryOrResponse& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const QueryOrResponse& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const QueryOrResponse& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const QueryOrResponse& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const QueryOrResponse& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const QueryOrResponse& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const QueryOrResponse& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const QueryOrResponse& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class QueryOrResponse_template : public Base_Template {
union {
QueryOrResponse::enum_type single_value;
struct {
unsigned int n_values;
QueryOrResponse_template *list_value;
} value_list;
};

void copy_template(const QueryOrResponse_template& other_value);

public:
QueryOrResponse_template();
QueryOrResponse_template(template_sel other_value);
QueryOrResponse_template(int other_value);
QueryOrResponse_template(QueryOrResponse::enum_type other_value);
QueryOrResponse_template(const QueryOrResponse& other_value);
QueryOrResponse_template(const OPTIONAL<QueryOrResponse>& other_value);
QueryOrResponse_template(const QueryOrResponse_template& other_value);
~QueryOrResponse_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryOrResponse_template& operator=(template_sel other_value);
QueryOrResponse_template& operator=(int other_value);
QueryOrResponse_template& operator=(QueryOrResponse::enum_type other_value);
QueryOrResponse_template& operator=(const QueryOrResponse& other_value);
QueryOrResponse_template& operator=(const OPTIONAL<QueryOrResponse>& other_value);
QueryOrResponse_template& operator=(const QueryOrResponse_template& other_value);

boolean match(QueryOrResponse::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const QueryOrResponse& other_value, boolean legacy = FALSE) const;
QueryOrResponse::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryOrResponse_template& list_item(unsigned int list_index);
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value, boolean legacy) const;
void log_matchv(const Base_Type* match_value, boolean legacy) const;
void log() const;
void log_match(const QueryOrResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
};

class DnsHeader : public Record_Type {
  INTEGER field_id;
  QueryOrResponse field_qr;
  INTEGER field_opCode;
  BOOLEAN field_aa;
  BOOLEAN field_tc;
  BOOLEAN field_rd;
  BOOLEAN field_ra;
  BITSTRING field_z;
  INTEGER field_rCode;
  INTEGER field_qdCount;
  INTEGER field_anCount;
  INTEGER field_nsCount;
  INTEGER field_arCount;
  Base_Type* fld_vec[13];
  void init_vec();
public:
  DnsHeader();
  DnsHeader(const DnsHeader& other_value);
  DnsHeader(const INTEGER& par_id,
    const QueryOrResponse& par_qr,
    const INTEGER& par_opCode,
    const BOOLEAN& par_aa,
    const BOOLEAN& par_tc,
    const BOOLEAN& par_rd,
    const BOOLEAN& par_ra,
    const BITSTRING& par_z,
    const INTEGER& par_rCode,
    const INTEGER& par_qdCount,
    const INTEGER& par_anCount,
    const INTEGER& par_nsCount,
    const INTEGER& par_arCount);
inline DnsHeader& operator=(const DnsHeader& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const DnsHeader& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const DnsHeader& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  inline QueryOrResponse& qr()
    {return field_qr;}
  inline const QueryOrResponse& qr() const
    {return field_qr;}
  inline INTEGER& opCode()
    {return field_opCode;}
  inline const INTEGER& opCode() const
    {return field_opCode;}
  inline BOOLEAN& aa()
    {return field_aa;}
  inline const BOOLEAN& aa() const
    {return field_aa;}
  inline BOOLEAN& tc()
    {return field_tc;}
  inline const BOOLEAN& tc() const
    {return field_tc;}
  inline BOOLEAN& rd()
    {return field_rd;}
  inline const BOOLEAN& rd() const
    {return field_rd;}
  inline BOOLEAN& ra()
    {return field_ra;}
  inline const BOOLEAN& ra() const
    {return field_ra;}
  inline BITSTRING& z()
    {return field_z;}
  inline const BITSTRING& z() const
    {return field_z;}
  inline INTEGER& rCode()
    {return field_rCode;}
  inline const INTEGER& rCode() const
    {return field_rCode;}
  inline INTEGER& qdCount()
    {return field_qdCount;}
  inline const INTEGER& qdCount() const
    {return field_qdCount;}
  inline INTEGER& anCount()
    {return field_anCount;}
  inline const INTEGER& anCount() const
    {return field_anCount;}
  inline INTEGER& nsCount()
    {return field_nsCount;}
  inline const INTEGER& nsCount() const
    {return field_nsCount;}
  inline INTEGER& arCount()
    {return field_arCount;}
  inline const INTEGER& arCount() const
    {return field_arCount;}
Base_Type* clone() const { return new DnsHeader(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 13; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class DnsHeader_template : public Record_Template {
void set_specific();
public:
DnsHeader_template(): Record_Template() {}
DnsHeader_template(template_sel other_value): Record_Template(other_value) {}
DnsHeader_template(const DnsHeader& other_value): Record_Template() { copy_value(&other_value); }
DnsHeader_template(const OPTIONAL<DnsHeader>& other_value): Record_Template() { copy_optional(&other_value); }
DnsHeader_template(const DnsHeader_template& other_value): Record_Template() { copy_template(other_value); }
DnsHeader_template& operator=(template_sel other_value);
DnsHeader_template& operator=(const DnsHeader& other_value);
DnsHeader_template& operator=(const OPTIONAL<DnsHeader>& other_value);
DnsHeader_template& operator=(const DnsHeader_template& other_value);
inline boolean match(const DnsHeader& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const DnsHeader& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
DnsHeader valueof() const;
inline DnsHeader_template& list_item(int list_index) const { return *(static_cast<DnsHeader_template*>(get_list_item(list_index))); }
INTEGER_template& id();
const INTEGER_template& id() const;
QueryOrResponse_template& qr();
const QueryOrResponse_template& qr() const;
INTEGER_template& opCode();
const INTEGER_template& opCode() const;
BOOLEAN_template& aa();
const BOOLEAN_template& aa() const;
BOOLEAN_template& tc();
const BOOLEAN_template& tc() const;
BOOLEAN_template& rd();
const BOOLEAN_template& rd() const;
BOOLEAN_template& ra();
const BOOLEAN_template& ra() const;
BITSTRING_template& z();
const BITSTRING_template& z() const;
INTEGER_template& rCode();
const INTEGER_template& rCode() const;
INTEGER_template& qdCount();
const INTEGER_template& qdCount() const;
INTEGER_template& anCount();
const INTEGER_template& anCount() const;
INTEGER_template& nsCount();
const INTEGER_template& nsCount() const;
INTEGER_template& arCount();
const INTEGER_template& arCount() const;
Record_Template* create() const { return new DnsHeader_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class QResourceRecords : public Record_Of_Type {

static const QResourceRecord UNBOUND_ELEM;

public:
QResourceRecords(): Record_Of_Type() {}
QResourceRecords(null_type other_value): Record_Of_Type(other_value) {}
QResourceRecords(const QResourceRecords& other_value): Record_Of_Type(other_value) {}
~QResourceRecords() { clean_up(); }

inline QResourceRecords& operator=(null_type other_value) { set_val(other_value); return *this; }
inline QResourceRecords& operator=(const QResourceRecords& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const QResourceRecords& other_value) const { return is_equal(&other_value); }
boolean operator!=(const QResourceRecords& other_value) const { return !is_equal(&other_value); }
QResourceRecord& operator[](int index_value);
QResourceRecord& operator[](const INTEGER& index_value);
const QResourceRecord& operator[](int index_value) const;
const QResourceRecord& operator[](const INTEGER& index_value) const;
QResourceRecords operator<<=(int rotate_count) const;
QResourceRecords operator<<=(const INTEGER& rotate_count) const;
QResourceRecords operator>>=(int rotate_count) const;
QResourceRecords operator>>=(const INTEGER& rotate_count) const;

QResourceRecords operator+(const QResourceRecords& other_value) const;

QResourceRecords substr(int index, int returncount) const;

QResourceRecords replace(int index, int len, const QResourceRecords& repl) const;

QResourceRecords replace(int index, int len, const QResourceRecords_template& repl) const;

Base_Type* clone() const { return new QResourceRecords(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
virtual boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int) { return FALSE; }
};

class QResourceRecords_template : public Record_Of_Template {

public:
QResourceRecords_template() {}
QResourceRecords_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
QResourceRecords_template(null_type other_value);
QResourceRecords_template(const QResourceRecords& other_value) { copy_value(&other_value); }
QResourceRecords_template(const OPTIONAL<QResourceRecords>& other_value) { copy_optional(&other_value); }
QResourceRecords_template(const QResourceRecords_template& other_value): Record_Of_Template() { copy_template(other_value); }
QResourceRecords_template& operator=(template_sel other_value);
QResourceRecords_template& operator=(null_type other_value);
QResourceRecords_template& operator=(const QResourceRecords& other_value);
QResourceRecords_template& operator=(const OPTIONAL<QResourceRecords>& other_value);
QResourceRecords_template& operator=(const QResourceRecords_template& other_value);

QResourceRecord_template& operator[](int index_value);
QResourceRecord_template& operator[](const INTEGER& index_value);
const QResourceRecord_template& operator[](int index_value) const;
const QResourceRecord_template& operator[](const INTEGER& index_value) const;
inline boolean match(const QResourceRecords& match_value, boolean legacy = FALSE) const { return matchv(&match_value, legacy); }
QResourceRecords valueof() const;
QResourceRecords substr(int index, int returncount) const;

QResourceRecords replace(int index, int len, const QResourceRecords_template& repl) const;

QResourceRecords replace(int index, int len, const QResourceRecords& repl) const;

inline QResourceRecords_template& list_item(int list_index) { return *(static_cast<QResourceRecords_template*>(get_list_item(list_index))); }
inline void log_match(const QResourceRecords& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
Record_Of_Template* create() const { return new QResourceRecords_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class ResourceRecords : public Record_Of_Type {

static const ResourceRecord UNBOUND_ELEM;

public:
ResourceRecords(): Record_Of_Type() {}
ResourceRecords(null_type other_value): Record_Of_Type(other_value) {}
ResourceRecords(const ResourceRecords& other_value): Record_Of_Type(other_value) {}
~ResourceRecords() { clean_up(); }

inline ResourceRecords& operator=(null_type other_value) { set_val(other_value); return *this; }
inline ResourceRecords& operator=(const ResourceRecords& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ResourceRecords& other_value) const { return is_equal(&other_value); }
boolean operator!=(const ResourceRecords& other_value) const { return !is_equal(&other_value); }
ResourceRecord& operator[](int index_value);
ResourceRecord& operator[](const INTEGER& index_value);
const ResourceRecord& operator[](int index_value) const;
const ResourceRecord& operator[](const INTEGER& index_value) const;
ResourceRecords operator<<=(int rotate_count) const;
ResourceRecords operator<<=(const INTEGER& rotate_count) const;
ResourceRecords operator>>=(int rotate_count) const;
ResourceRecords operator>>=(const INTEGER& rotate_count) const;

ResourceRecords operator+(const ResourceRecords& other_value) const;

ResourceRecords substr(int index, int returncount) const;

ResourceRecords replace(int index, int len, const ResourceRecords& repl) const;

ResourceRecords replace(int index, int len, const ResourceRecords_template& repl) const;

Base_Type* clone() const { return new ResourceRecords(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
virtual boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int) { return FALSE; }
};

class ResourceRecords_template : public Record_Of_Template {

public:
ResourceRecords_template() {}
ResourceRecords_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
ResourceRecords_template(null_type other_value);
ResourceRecords_template(const ResourceRecords& other_value) { copy_value(&other_value); }
ResourceRecords_template(const OPTIONAL<ResourceRecords>& other_value) { copy_optional(&other_value); }
ResourceRecords_template(const ResourceRecords_template& other_value): Record_Of_Template() { copy_template(other_value); }
ResourceRecords_template& operator=(template_sel other_value);
ResourceRecords_template& operator=(null_type other_value);
ResourceRecords_template& operator=(const ResourceRecords& other_value);
ResourceRecords_template& operator=(const OPTIONAL<ResourceRecords>& other_value);
ResourceRecords_template& operator=(const ResourceRecords_template& other_value);

ResourceRecord_template& operator[](int index_value);
ResourceRecord_template& operator[](const INTEGER& index_value);
const ResourceRecord_template& operator[](int index_value) const;
const ResourceRecord_template& operator[](const INTEGER& index_value) const;
inline boolean match(const ResourceRecords& match_value, boolean legacy = FALSE) const { return matchv(&match_value, legacy); }
ResourceRecords valueof() const;
ResourceRecords substr(int index, int returncount) const;

ResourceRecords replace(int index, int len, const ResourceRecords_template& repl) const;

ResourceRecords replace(int index, int len, const ResourceRecords& repl) const;

inline ResourceRecords_template& list_item(int list_index) { return *(static_cast<ResourceRecords_template*>(get_list_item(list_index))); }
inline void log_match(const ResourceRecords& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
Record_Of_Template* create() const { return new ResourceRecords_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class PDU__DNS : public Record_Type {
  DnsHeader field_header;
  QResourceRecords field_queries;
  ResourceRecords field_answers;
  ResourceRecords field_nameServerRecords;
  ResourceRecords field_additionalRecords;
  Base_Type* fld_vec[5];
  void init_vec();
public:
  PDU__DNS();
  PDU__DNS(const PDU__DNS& other_value);
  PDU__DNS(const DnsHeader& par_header,
    const QResourceRecords& par_queries,
    const ResourceRecords& par_answers,
    const ResourceRecords& par_nameServerRecords,
    const ResourceRecords& par_additionalRecords);
inline PDU__DNS& operator=(const PDU__DNS& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PDU__DNS& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const PDU__DNS& other_value) const
    { return !is_equal(&other_value); }

  inline DnsHeader& header()
    {return field_header;}
  inline const DnsHeader& header() const
    {return field_header;}
  inline QResourceRecords& queries()
    {return field_queries;}
  inline const QResourceRecords& queries() const
    {return field_queries;}
  inline ResourceRecords& answers()
    {return field_answers;}
  inline const ResourceRecords& answers() const
    {return field_answers;}
  inline ResourceRecords& nameServerRecords()
    {return field_nameServerRecords;}
  inline const ResourceRecords& nameServerRecords() const
    {return field_nameServerRecords;}
  inline ResourceRecords& additionalRecords()
    {return field_additionalRecords;}
  inline const ResourceRecords& additionalRecords() const
    {return field_additionalRecords;}
Base_Type* clone() const { return new PDU__DNS(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 5; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class PDU__DNS_template : public Record_Template {
void set_specific();
public:
PDU__DNS_template(): Record_Template() {}
PDU__DNS_template(template_sel other_value): Record_Template(other_value) {}
PDU__DNS_template(const PDU__DNS& other_value): Record_Template() { copy_value(&other_value); }
PDU__DNS_template(const OPTIONAL<PDU__DNS>& other_value): Record_Template() { copy_optional(&other_value); }
PDU__DNS_template(const PDU__DNS_template& other_value): Record_Template() { copy_template(other_value); }
PDU__DNS_template& operator=(template_sel other_value);
PDU__DNS_template& operator=(const PDU__DNS& other_value);
PDU__DNS_template& operator=(const OPTIONAL<PDU__DNS>& other_value);
PDU__DNS_template& operator=(const PDU__DNS_template& other_value);
inline boolean match(const PDU__DNS& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const PDU__DNS& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
PDU__DNS valueof() const;
inline PDU__DNS_template& list_item(int list_index) const { return *(static_cast<PDU__DNS_template*>(get_list_item(list_index))); }
DnsHeader_template& header();
const DnsHeader_template& header() const;
QResourceRecords_template& queries();
const QResourceRecords_template& queries() const;
ResourceRecords_template& answers();
const ResourceRecords_template& answers() const;
ResourceRecords_template& nameServerRecords();
const ResourceRecords_template& nameServerRecords() const;
ResourceRecords_template& additionalRecords();
const ResourceRecords_template& additionalRecords() const;
Record_Template* create() const { return new PDU__DNS_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class QResourceRecord : public Record_Type {
  CHARSTRING field_qName;
  INTEGER field_qType;
  INTEGER field_qClass;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  QResourceRecord();
  QResourceRecord(const QResourceRecord& other_value);
  QResourceRecord(const CHARSTRING& par_qName,
    const INTEGER& par_qType,
    const INTEGER& par_qClass);
inline QResourceRecord& operator=(const QResourceRecord& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const QResourceRecord& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const QResourceRecord& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& qName()
    {return field_qName;}
  inline const CHARSTRING& qName() const
    {return field_qName;}
  inline INTEGER& qType()
    {return field_qType;}
  inline const INTEGER& qType() const
    {return field_qType;}
  inline INTEGER& qClass()
    {return field_qClass;}
  inline const INTEGER& qClass() const
    {return field_qClass;}
Base_Type* clone() const { return new QResourceRecord(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class QResourceRecord_template : public Record_Template {
void set_specific();
public:
QResourceRecord_template(): Record_Template() {}
QResourceRecord_template(template_sel other_value): Record_Template(other_value) {}
QResourceRecord_template(const QResourceRecord& other_value): Record_Template() { copy_value(&other_value); }
QResourceRecord_template(const OPTIONAL<QResourceRecord>& other_value): Record_Template() { copy_optional(&other_value); }
QResourceRecord_template(const QResourceRecord_template& other_value): Record_Template() { copy_template(other_value); }
QResourceRecord_template& operator=(template_sel other_value);
QResourceRecord_template& operator=(const QResourceRecord& other_value);
QResourceRecord_template& operator=(const OPTIONAL<QResourceRecord>& other_value);
QResourceRecord_template& operator=(const QResourceRecord_template& other_value);
inline boolean match(const QResourceRecord& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const QResourceRecord& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
QResourceRecord valueof() const;
inline QResourceRecord_template& list_item(int list_index) const { return *(static_cast<QResourceRecord_template*>(get_list_item(list_index))); }
CHARSTRING_template& qName();
const CHARSTRING_template& qName() const;
INTEGER_template& qType();
const INTEGER_template& qType() const;
INTEGER_template& qClass();
const INTEGER_template& qClass() const;
Record_Template* create() const { return new QResourceRecord_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class ResourceData : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_cName = 1, ALT_hInfo = 2, ALT_mb = 3, ALT_md = 4, ALT_mf = 5, ALT_mg = 6, ALT_mInfo = 7, ALT_mr = 8, ALT_mx = 9, ALT_rd__null = 10, ALT_ns = 11, ALT_ptr = 12, ALT_soa = 13, ALT_txt = 14, ALT_a = 15, ALT_wks = 16, ALT_srv = 17, ALT_naptr = 18, ALT_aaaa = 19, ALT_unsupported = 20, ALT_undecodable = 21 };
private:
union_selection_type union_selection;
union {
CHARSTRING *field_cName;
RDataHInfo *field_hInfo;
CHARSTRING *field_mb;
CHARSTRING *field_md;
CHARSTRING *field_mf;
CHARSTRING *field_mg;
RDataMInfo *field_mInfo;
CHARSTRING *field_mr;
RDataMX *field_mx;
OCTETSTRING *field_rd__null;
CHARSTRING *field_ns;
CHARSTRING *field_ptr;
RDataSOA *field_soa;
RDataTXT *field_txt;
OCTETSTRING *field_a;
RDataWKS *field_wks;
RDataSRV *field_srv;
RDataNAPTR *field_naptr;
OCTETSTRING *field_aaaa;
OCTETSTRING *field_unsupported;
OCTETSTRING *field_undecodable;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const ResourceData& other_value);

public:
ResourceData();
ResourceData(const ResourceData& other_value);
~ResourceData();
ResourceData& operator=(const ResourceData& other_value);
boolean operator==(const ResourceData& other_value) const;
inline boolean operator!=(const ResourceData& other_value) const { return !(*this == other_value); }
CHARSTRING& cName();
const CHARSTRING& cName() const;
RDataHInfo& hInfo();
const RDataHInfo& hInfo() const;
CHARSTRING& mb();
const CHARSTRING& mb() const;
CHARSTRING& md();
const CHARSTRING& md() const;
CHARSTRING& mf();
const CHARSTRING& mf() const;
CHARSTRING& mg();
const CHARSTRING& mg() const;
RDataMInfo& mInfo();
const RDataMInfo& mInfo() const;
CHARSTRING& mr();
const CHARSTRING& mr() const;
RDataMX& mx();
const RDataMX& mx() const;
OCTETSTRING& rd__null();
const OCTETSTRING& rd__null() const;
CHARSTRING& ns();
const CHARSTRING& ns() const;
CHARSTRING& ptr();
const CHARSTRING& ptr() const;
RDataSOA& soa();
const RDataSOA& soa() const;
RDataTXT& txt();
const RDataTXT& txt() const;
OCTETSTRING& a();
const OCTETSTRING& a() const;
RDataWKS& wks();
const RDataWKS& wks() const;
RDataSRV& srv();
const RDataSRV& srv() const;
RDataNAPTR& naptr();
const RDataNAPTR& naptr() const;
OCTETSTRING& aaaa();
const OCTETSTRING& aaaa() const;
OCTETSTRING& unsupported();
const OCTETSTRING& unsupported() const;
OCTETSTRING& undecodable();
const OCTETSTRING& undecodable() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
boolean is_equal(const Base_Type* other_value) const;
void set_value(const Base_Type* other_value);
Base_Type* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
Erroneous_descriptor_t* get_err_descr() const { return err_descr; }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ResourceData_template : public Base_Template {
union {
struct {
ResourceData::union_selection_type union_selection;
union {
CHARSTRING_template *field_cName;
RDataHInfo_template *field_hInfo;
CHARSTRING_template *field_mb;
CHARSTRING_template *field_md;
CHARSTRING_template *field_mf;
CHARSTRING_template *field_mg;
RDataMInfo_template *field_mInfo;
CHARSTRING_template *field_mr;
RDataMX_template *field_mx;
OCTETSTRING_template *field_rd__null;
CHARSTRING_template *field_ns;
CHARSTRING_template *field_ptr;
RDataSOA_template *field_soa;
RDataTXT_template *field_txt;
OCTETSTRING_template *field_a;
RDataWKS_template *field_wks;
RDataSRV_template *field_srv;
RDataNAPTR_template *field_naptr;
OCTETSTRING_template *field_aaaa;
OCTETSTRING_template *field_unsupported;
OCTETSTRING_template *field_undecodable;
};
} single_value;
struct {
unsigned int n_values;
ResourceData_template *list_value;
} value_list;
};
Erroneous_descriptor_t* err_descr;
void copy_value(const ResourceData& other_value);

void copy_template(const ResourceData_template& other_value);

public:
ResourceData_template();
ResourceData_template(template_sel other_value);
ResourceData_template(const ResourceData& other_value);
ResourceData_template(const OPTIONAL<ResourceData>& other_value);
ResourceData_template(const ResourceData_template& other_value);
~ResourceData_template();
void clean_up();
ResourceData_template& operator=(template_sel other_value);
ResourceData_template& operator=(const ResourceData& other_value);
ResourceData_template& operator=(const OPTIONAL<ResourceData>& other_value);
ResourceData_template& operator=(const ResourceData_template& other_value);
boolean match(const ResourceData& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ResourceData valueof() const;
ResourceData_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CHARSTRING_template& cName();
const CHARSTRING_template& cName() const;
RDataHInfo_template& hInfo();
const RDataHInfo_template& hInfo() const;
CHARSTRING_template& mb();
const CHARSTRING_template& mb() const;
CHARSTRING_template& md();
const CHARSTRING_template& md() const;
CHARSTRING_template& mf();
const CHARSTRING_template& mf() const;
CHARSTRING_template& mg();
const CHARSTRING_template& mg() const;
RDataMInfo_template& mInfo();
const RDataMInfo_template& mInfo() const;
CHARSTRING_template& mr();
const CHARSTRING_template& mr() const;
RDataMX_template& mx();
const RDataMX_template& mx() const;
OCTETSTRING_template& rd__null();
const OCTETSTRING_template& rd__null() const;
CHARSTRING_template& ns();
const CHARSTRING_template& ns() const;
CHARSTRING_template& ptr();
const CHARSTRING_template& ptr() const;
RDataSOA_template& soa();
const RDataSOA_template& soa() const;
RDataTXT_template& txt();
const RDataTXT_template& txt() const;
OCTETSTRING_template& a();
const OCTETSTRING_template& a() const;
RDataWKS_template& wks();
const RDataWKS_template& wks() const;
RDataSRV_template& srv();
const RDataSRV_template& srv() const;
RDataNAPTR_template& naptr();
const RDataNAPTR_template& naptr() const;
OCTETSTRING_template& aaaa();
const OCTETSTRING_template& aaaa() const;
OCTETSTRING_template& unsupported();
const OCTETSTRING_template& unsupported() const;
OCTETSTRING_template& undecodable();
const OCTETSTRING_template& undecodable() const;
boolean ischosen(ResourceData::union_selection_type checked_selection) const;
void set_err_descr(Erroneous_descriptor_t* p_err_descr) { err_descr=p_err_descr; }
void valueofv(Base_Type* value) const;
void set_value(template_sel other_value);
void copy_value(const Base_Type* other_value);
Base_Template* clone() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean matchv(const Base_Type* other_value, boolean legacy) const;
void log_matchv(const Base_Type* match_value, boolean legacy) const;
void log() const;
void log_match(const ResourceData& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ResourceRecord : public Record_Type {
  CHARSTRING field_name;
  INTEGER field_rrType;
  INTEGER field_rrClass;
  OCTETSTRING field_ttl;
  INTEGER field_rdLength;
  ResourceData field_rData;
  Base_Type* fld_vec[6];
  void init_vec();
public:
  ResourceRecord();
  ResourceRecord(const ResourceRecord& other_value);
  ResourceRecord(const CHARSTRING& par_name,
    const INTEGER& par_rrType,
    const INTEGER& par_rrClass,
    const OCTETSTRING& par_ttl,
    const INTEGER& par_rdLength,
    const ResourceData& par_rData);
inline ResourceRecord& operator=(const ResourceRecord& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const ResourceRecord& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const ResourceRecord& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline INTEGER& rrType()
    {return field_rrType;}
  inline const INTEGER& rrType() const
    {return field_rrType;}
  inline INTEGER& rrClass()
    {return field_rrClass;}
  inline const INTEGER& rrClass() const
    {return field_rrClass;}
  inline OCTETSTRING& ttl()
    {return field_ttl;}
  inline const OCTETSTRING& ttl() const
    {return field_ttl;}
  inline INTEGER& rdLength()
    {return field_rdLength;}
  inline const INTEGER& rdLength() const
    {return field_rdLength;}
  inline ResourceData& rData()
    {return field_rData;}
  inline const ResourceData& rData() const
    {return field_rData;}
Base_Type* clone() const { return new ResourceRecord(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 6; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class ResourceRecord_template : public Record_Template {
void set_specific();
public:
ResourceRecord_template(): Record_Template() {}
ResourceRecord_template(template_sel other_value): Record_Template(other_value) {}
ResourceRecord_template(const ResourceRecord& other_value): Record_Template() { copy_value(&other_value); }
ResourceRecord_template(const OPTIONAL<ResourceRecord>& other_value): Record_Template() { copy_optional(&other_value); }
ResourceRecord_template(const ResourceRecord_template& other_value): Record_Template() { copy_template(other_value); }
ResourceRecord_template& operator=(template_sel other_value);
ResourceRecord_template& operator=(const ResourceRecord& other_value);
ResourceRecord_template& operator=(const OPTIONAL<ResourceRecord>& other_value);
ResourceRecord_template& operator=(const ResourceRecord_template& other_value);
inline boolean match(const ResourceRecord& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const ResourceRecord& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
ResourceRecord valueof() const;
inline ResourceRecord_template& list_item(int list_index) const { return *(static_cast<ResourceRecord_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
INTEGER_template& rrType();
const INTEGER_template& rrType() const;
INTEGER_template& rrClass();
const INTEGER_template& rrClass() const;
OCTETSTRING_template& ttl();
const OCTETSTRING_template& ttl() const;
INTEGER_template& rdLength();
const INTEGER_template& rdLength() const;
ResourceData_template& rData();
const ResourceData_template& rData() const;
Record_Template* create() const { return new ResourceRecord_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataHInfo : public Record_Type {
  CHARSTRING field_cpu;
  CHARSTRING field_os;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  RDataHInfo();
  RDataHInfo(const RDataHInfo& other_value);
  RDataHInfo(const CHARSTRING& par_cpu,
    const CHARSTRING& par_os);
inline RDataHInfo& operator=(const RDataHInfo& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataHInfo& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataHInfo& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& cpu()
    {return field_cpu;}
  inline const CHARSTRING& cpu() const
    {return field_cpu;}
  inline CHARSTRING& os()
    {return field_os;}
  inline const CHARSTRING& os() const
    {return field_os;}
Base_Type* clone() const { return new RDataHInfo(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataHInfo_template : public Record_Template {
void set_specific();
public:
RDataHInfo_template(): Record_Template() {}
RDataHInfo_template(template_sel other_value): Record_Template(other_value) {}
RDataHInfo_template(const RDataHInfo& other_value): Record_Template() { copy_value(&other_value); }
RDataHInfo_template(const OPTIONAL<RDataHInfo>& other_value): Record_Template() { copy_optional(&other_value); }
RDataHInfo_template(const RDataHInfo_template& other_value): Record_Template() { copy_template(other_value); }
RDataHInfo_template& operator=(template_sel other_value);
RDataHInfo_template& operator=(const RDataHInfo& other_value);
RDataHInfo_template& operator=(const OPTIONAL<RDataHInfo>& other_value);
RDataHInfo_template& operator=(const RDataHInfo_template& other_value);
inline boolean match(const RDataHInfo& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataHInfo& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataHInfo valueof() const;
inline RDataHInfo_template& list_item(int list_index) const { return *(static_cast<RDataHInfo_template*>(get_list_item(list_index))); }
CHARSTRING_template& cpu();
const CHARSTRING_template& cpu() const;
CHARSTRING_template& os();
const CHARSTRING_template& os() const;
Record_Template* create() const { return new RDataHInfo_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataMInfo : public Record_Type {
  CHARSTRING field_rMailBx;
  CHARSTRING field_eMailBx;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  RDataMInfo();
  RDataMInfo(const RDataMInfo& other_value);
  RDataMInfo(const CHARSTRING& par_rMailBx,
    const CHARSTRING& par_eMailBx);
inline RDataMInfo& operator=(const RDataMInfo& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataMInfo& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataMInfo& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& rMailBx()
    {return field_rMailBx;}
  inline const CHARSTRING& rMailBx() const
    {return field_rMailBx;}
  inline CHARSTRING& eMailBx()
    {return field_eMailBx;}
  inline const CHARSTRING& eMailBx() const
    {return field_eMailBx;}
Base_Type* clone() const { return new RDataMInfo(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataMInfo_template : public Record_Template {
void set_specific();
public:
RDataMInfo_template(): Record_Template() {}
RDataMInfo_template(template_sel other_value): Record_Template(other_value) {}
RDataMInfo_template(const RDataMInfo& other_value): Record_Template() { copy_value(&other_value); }
RDataMInfo_template(const OPTIONAL<RDataMInfo>& other_value): Record_Template() { copy_optional(&other_value); }
RDataMInfo_template(const RDataMInfo_template& other_value): Record_Template() { copy_template(other_value); }
RDataMInfo_template& operator=(template_sel other_value);
RDataMInfo_template& operator=(const RDataMInfo& other_value);
RDataMInfo_template& operator=(const OPTIONAL<RDataMInfo>& other_value);
RDataMInfo_template& operator=(const RDataMInfo_template& other_value);
inline boolean match(const RDataMInfo& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataMInfo& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataMInfo valueof() const;
inline RDataMInfo_template& list_item(int list_index) const { return *(static_cast<RDataMInfo_template*>(get_list_item(list_index))); }
CHARSTRING_template& rMailBx();
const CHARSTRING_template& rMailBx() const;
CHARSTRING_template& eMailBx();
const CHARSTRING_template& eMailBx() const;
Record_Template* create() const { return new RDataMInfo_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataMX : public Record_Type {
  INTEGER field_preference;
  CHARSTRING field_exchange;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  RDataMX();
  RDataMX(const RDataMX& other_value);
  RDataMX(const INTEGER& par_preference,
    const CHARSTRING& par_exchange);
inline RDataMX& operator=(const RDataMX& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataMX& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataMX& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& preference()
    {return field_preference;}
  inline const INTEGER& preference() const
    {return field_preference;}
  inline CHARSTRING& exchange()
    {return field_exchange;}
  inline const CHARSTRING& exchange() const
    {return field_exchange;}
Base_Type* clone() const { return new RDataMX(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataMX_template : public Record_Template {
void set_specific();
public:
RDataMX_template(): Record_Template() {}
RDataMX_template(template_sel other_value): Record_Template(other_value) {}
RDataMX_template(const RDataMX& other_value): Record_Template() { copy_value(&other_value); }
RDataMX_template(const OPTIONAL<RDataMX>& other_value): Record_Template() { copy_optional(&other_value); }
RDataMX_template(const RDataMX_template& other_value): Record_Template() { copy_template(other_value); }
RDataMX_template& operator=(template_sel other_value);
RDataMX_template& operator=(const RDataMX& other_value);
RDataMX_template& operator=(const OPTIONAL<RDataMX>& other_value);
RDataMX_template& operator=(const RDataMX_template& other_value);
inline boolean match(const RDataMX& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataMX& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataMX valueof() const;
inline RDataMX_template& list_item(int list_index) const { return *(static_cast<RDataMX_template*>(get_list_item(list_index))); }
INTEGER_template& preference();
const INTEGER_template& preference() const;
CHARSTRING_template& exchange();
const CHARSTRING_template& exchange() const;
Record_Template* create() const { return new RDataMX_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataSOA : public Record_Type {
  CHARSTRING field_mName;
  CHARSTRING field_rName;
  OCTETSTRING field_serial;
  OCTETSTRING field_refresh;
  OCTETSTRING field_retry;
  OCTETSTRING field_expire;
  OCTETSTRING field_minimum;
  Base_Type* fld_vec[7];
  void init_vec();
public:
  RDataSOA();
  RDataSOA(const RDataSOA& other_value);
  RDataSOA(const CHARSTRING& par_mName,
    const CHARSTRING& par_rName,
    const OCTETSTRING& par_serial,
    const OCTETSTRING& par_refresh,
    const OCTETSTRING& par_retry,
    const OCTETSTRING& par_expire,
    const OCTETSTRING& par_minimum);
inline RDataSOA& operator=(const RDataSOA& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataSOA& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataSOA& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& mName()
    {return field_mName;}
  inline const CHARSTRING& mName() const
    {return field_mName;}
  inline CHARSTRING& rName()
    {return field_rName;}
  inline const CHARSTRING& rName() const
    {return field_rName;}
  inline OCTETSTRING& serial()
    {return field_serial;}
  inline const OCTETSTRING& serial() const
    {return field_serial;}
  inline OCTETSTRING& refresh()
    {return field_refresh;}
  inline const OCTETSTRING& refresh() const
    {return field_refresh;}
  inline OCTETSTRING& retry()
    {return field_retry;}
  inline const OCTETSTRING& retry() const
    {return field_retry;}
  inline OCTETSTRING& expire()
    {return field_expire;}
  inline const OCTETSTRING& expire() const
    {return field_expire;}
  inline OCTETSTRING& minimum()
    {return field_minimum;}
  inline const OCTETSTRING& minimum() const
    {return field_minimum;}
Base_Type* clone() const { return new RDataSOA(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 7; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataSOA_template : public Record_Template {
void set_specific();
public:
RDataSOA_template(): Record_Template() {}
RDataSOA_template(template_sel other_value): Record_Template(other_value) {}
RDataSOA_template(const RDataSOA& other_value): Record_Template() { copy_value(&other_value); }
RDataSOA_template(const OPTIONAL<RDataSOA>& other_value): Record_Template() { copy_optional(&other_value); }
RDataSOA_template(const RDataSOA_template& other_value): Record_Template() { copy_template(other_value); }
RDataSOA_template& operator=(template_sel other_value);
RDataSOA_template& operator=(const RDataSOA& other_value);
RDataSOA_template& operator=(const OPTIONAL<RDataSOA>& other_value);
RDataSOA_template& operator=(const RDataSOA_template& other_value);
inline boolean match(const RDataSOA& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataSOA& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataSOA valueof() const;
inline RDataSOA_template& list_item(int list_index) const { return *(static_cast<RDataSOA_template*>(get_list_item(list_index))); }
CHARSTRING_template& mName();
const CHARSTRING_template& mName() const;
CHARSTRING_template& rName();
const CHARSTRING_template& rName() const;
OCTETSTRING_template& serial();
const OCTETSTRING_template& serial() const;
OCTETSTRING_template& refresh();
const OCTETSTRING_template& refresh() const;
OCTETSTRING_template& retry();
const OCTETSTRING_template& retry() const;
OCTETSTRING_template& expire();
const OCTETSTRING_template& expire() const;
OCTETSTRING_template& minimum();
const OCTETSTRING_template& minimum() const;
Record_Template* create() const { return new RDataSOA_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataWKS : public Record_Type {
  OCTETSTRING field_addr;
  INTEGER field_protocol;
  OCTETSTRING field_bitmap;
  Base_Type* fld_vec[3];
  void init_vec();
public:
  RDataWKS();
  RDataWKS(const RDataWKS& other_value);
  RDataWKS(const OCTETSTRING& par_addr,
    const INTEGER& par_protocol,
    const OCTETSTRING& par_bitmap);
inline RDataWKS& operator=(const RDataWKS& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataWKS& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataWKS& other_value) const
    { return !is_equal(&other_value); }

  inline OCTETSTRING& addr()
    {return field_addr;}
  inline const OCTETSTRING& addr() const
    {return field_addr;}
  inline INTEGER& protocol()
    {return field_protocol;}
  inline const INTEGER& protocol() const
    {return field_protocol;}
  inline OCTETSTRING& bitmap()
    {return field_bitmap;}
  inline const OCTETSTRING& bitmap() const
    {return field_bitmap;}
Base_Type* clone() const { return new RDataWKS(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 3; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataWKS_template : public Record_Template {
void set_specific();
public:
RDataWKS_template(): Record_Template() {}
RDataWKS_template(template_sel other_value): Record_Template(other_value) {}
RDataWKS_template(const RDataWKS& other_value): Record_Template() { copy_value(&other_value); }
RDataWKS_template(const OPTIONAL<RDataWKS>& other_value): Record_Template() { copy_optional(&other_value); }
RDataWKS_template(const RDataWKS_template& other_value): Record_Template() { copy_template(other_value); }
RDataWKS_template& operator=(template_sel other_value);
RDataWKS_template& operator=(const RDataWKS& other_value);
RDataWKS_template& operator=(const OPTIONAL<RDataWKS>& other_value);
RDataWKS_template& operator=(const RDataWKS_template& other_value);
inline boolean match(const RDataWKS& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataWKS& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataWKS valueof() const;
inline RDataWKS_template& list_item(int list_index) const { return *(static_cast<RDataWKS_template*>(get_list_item(list_index))); }
OCTETSTRING_template& addr();
const OCTETSTRING_template& addr() const;
INTEGER_template& protocol();
const INTEGER_template& protocol() const;
OCTETSTRING_template& bitmap();
const OCTETSTRING_template& bitmap() const;
Record_Template* create() const { return new RDataWKS_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataSRV : public Record_Type {
  INTEGER field_priority;
  INTEGER field_weight;
  INTEGER field_portnum;
  CHARSTRING field_target;
  Base_Type* fld_vec[4];
  void init_vec();
public:
  RDataSRV();
  RDataSRV(const RDataSRV& other_value);
  RDataSRV(const INTEGER& par_priority,
    const INTEGER& par_weight,
    const INTEGER& par_portnum,
    const CHARSTRING& par_target);
inline RDataSRV& operator=(const RDataSRV& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataSRV& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataSRV& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& priority()
    {return field_priority;}
  inline const INTEGER& priority() const
    {return field_priority;}
  inline INTEGER& weight()
    {return field_weight;}
  inline const INTEGER& weight() const
    {return field_weight;}
  inline INTEGER& portnum()
    {return field_portnum;}
  inline const INTEGER& portnum() const
    {return field_portnum;}
  inline CHARSTRING& target()
    {return field_target;}
  inline const CHARSTRING& target() const
    {return field_target;}
Base_Type* clone() const { return new RDataSRV(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 4; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataSRV_template : public Record_Template {
void set_specific();
public:
RDataSRV_template(): Record_Template() {}
RDataSRV_template(template_sel other_value): Record_Template(other_value) {}
RDataSRV_template(const RDataSRV& other_value): Record_Template() { copy_value(&other_value); }
RDataSRV_template(const OPTIONAL<RDataSRV>& other_value): Record_Template() { copy_optional(&other_value); }
RDataSRV_template(const RDataSRV_template& other_value): Record_Template() { copy_template(other_value); }
RDataSRV_template& operator=(template_sel other_value);
RDataSRV_template& operator=(const RDataSRV& other_value);
RDataSRV_template& operator=(const OPTIONAL<RDataSRV>& other_value);
RDataSRV_template& operator=(const RDataSRV_template& other_value);
inline boolean match(const RDataSRV& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataSRV& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataSRV valueof() const;
inline RDataSRV_template& list_item(int list_index) const { return *(static_cast<RDataSRV_template*>(get_list_item(list_index))); }
INTEGER_template& priority();
const INTEGER_template& priority() const;
INTEGER_template& weight();
const INTEGER_template& weight() const;
INTEGER_template& portnum();
const INTEGER_template& portnum() const;
CHARSTRING_template& target();
const CHARSTRING_template& target() const;
Record_Template* create() const { return new RDataSRV_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class RDataNAPTR : public Record_Type {
  INTEGER field_order;
  INTEGER field_preference;
  CHARSTRING field_flags;
  CHARSTRING field_services;
  CHARSTRING field_regexpString;
  CHARSTRING field_replacement;
  Base_Type* fld_vec[6];
  void init_vec();
public:
  RDataNAPTR();
  RDataNAPTR(const RDataNAPTR& other_value);
  RDataNAPTR(const INTEGER& par_order,
    const INTEGER& par_preference,
    const CHARSTRING& par_flags,
    const CHARSTRING& par_services,
    const CHARSTRING& par_regexpString,
    const CHARSTRING& par_replacement);
inline RDataNAPTR& operator=(const RDataNAPTR& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const RDataNAPTR& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const RDataNAPTR& other_value) const
    { return !is_equal(&other_value); }

  inline INTEGER& order()
    {return field_order;}
  inline const INTEGER& order() const
    {return field_order;}
  inline INTEGER& preference()
    {return field_preference;}
  inline const INTEGER& preference() const
    {return field_preference;}
  inline CHARSTRING& flags()
    {return field_flags;}
  inline const CHARSTRING& flags() const
    {return field_flags;}
  inline CHARSTRING& services()
    {return field_services;}
  inline const CHARSTRING& services() const
    {return field_services;}
  inline CHARSTRING& regexpString()
    {return field_regexpString;}
  inline const CHARSTRING& regexpString() const
    {return field_regexpString;}
  inline CHARSTRING& replacement()
    {return field_replacement;}
  inline const CHARSTRING& replacement() const
    {return field_replacement;}
Base_Type* clone() const { return new RDataNAPTR(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 6; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class RDataNAPTR_template : public Record_Template {
void set_specific();
public:
RDataNAPTR_template(): Record_Template() {}
RDataNAPTR_template(template_sel other_value): Record_Template(other_value) {}
RDataNAPTR_template(const RDataNAPTR& other_value): Record_Template() { copy_value(&other_value); }
RDataNAPTR_template(const OPTIONAL<RDataNAPTR>& other_value): Record_Template() { copy_optional(&other_value); }
RDataNAPTR_template(const RDataNAPTR_template& other_value): Record_Template() { copy_template(other_value); }
RDataNAPTR_template& operator=(template_sel other_value);
RDataNAPTR_template& operator=(const RDataNAPTR& other_value);
RDataNAPTR_template& operator=(const OPTIONAL<RDataNAPTR>& other_value);
RDataNAPTR_template& operator=(const RDataNAPTR_template& other_value);
inline boolean match(const RDataNAPTR& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const RDataNAPTR& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
RDataNAPTR valueof() const;
inline RDataNAPTR_template& list_item(int list_index) const { return *(static_cast<RDataNAPTR_template*>(get_list_item(list_index))); }
INTEGER_template& order();
const INTEGER_template& order() const;
INTEGER_template& preference();
const INTEGER_template& preference() const;
CHARSTRING_template& flags();
const CHARSTRING_template& flags() const;
CHARSTRING_template& services();
const CHARSTRING_template& services() const;
CHARSTRING_template& regexpString();
const CHARSTRING_template& regexpString() const;
CHARSTRING_template& replacement();
const CHARSTRING_template& replacement() const;
Record_Template* create() const { return new RDataNAPTR_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};


/* Function prototypes */

extern OCTETSTRING enc__PDU__DNS(const PDU__DNS& msg, const BOOLEAN& doCompression, const BOOLEAN& autoLengthCalc);
extern PDU__DNS dec__PDU__DNS(const OCTETSTRING& stream);

/* Global variable declarations */

extern const TTCN_Typedescriptor_t UInt16_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_id_descr_;
extern const TTCN_Typedescriptor_t QueryOrResponse_descr_;
extern const TTCN_Typedescriptor_t OpCode_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_opCode_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_aa_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_tc_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_rd_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_ra_descr_;
extern const TTCN_RAWdescriptor_t DnsHeader_z_raw_;
extern const TTCN_Typedescriptor_t DnsHeader_z_descr_;
extern const TTCN_Typedescriptor_t ResponseCode_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_rCode_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_qdCount_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_anCount_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_nsCount_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_arCount_descr_;
extern const TTCN_Typedescriptor_t DnsHeader_descr_;
extern const TTCN_Typedescriptor_t QResourceRecords_descr_;
extern const TTCN_Typedescriptor_t ResourceRecords_descr_;
extern const TTCN_Typedescriptor_t PDU__DNS_descr_;
extern const INTEGER& DNS__OP__QUERY;
extern const INTEGER& DNS__OP__IQUERY;
extern const INTEGER& DNS__OP__STATUS;
extern const INTEGER& DNS__OP__UPDATE;
extern const INTEGER& DNS__NO__ERROR;
extern const INTEGER& DNS__FORMAT__ERROR;
extern const INTEGER& DNS__SERVER__FAILURE;
extern const INTEGER& DNS__NAME__ERROR;
extern const INTEGER& DNS__NOT__IMPLEMENTED;
extern const INTEGER& DNS__REFUSED;
extern const INTEGER& DNS__YXDOMAIN;
extern const INTEGER& DNS__YXRRSET;
extern const INTEGER& DNS__NXRRSET;
extern const INTEGER& DNS__NOTAUTH;
extern const INTEGER& DNS__NOTZONE;
extern const TTCN_Typedescriptor_t CharStr255_descr_;
extern const TTCN_Typedescriptor_t DomainName_descr_;
extern const TTCN_Typedescriptor_t QResourceRecord_qName_descr_;
extern const TTCN_Typedescriptor_t RRType_descr_;
extern const TTCN_Typedescriptor_t QResourceRecord_qType_descr_;
extern const TTCN_Typedescriptor_t RRClass_descr_;
extern const TTCN_Typedescriptor_t QResourceRecord_qClass_descr_;
extern const TTCN_Typedescriptor_t QResourceRecord_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_name_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_rrType_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_rrClass_descr_;
extern const TTCN_RAWdescriptor_t UInt32_raw_;
extern const TTCN_Typedescriptor_t UInt32_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_ttl_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_rdLength_descr_;
extern const TTCN_Typedescriptor_t ResourceData_descr_;
extern const TTCN_Typedescriptor_t RDataCName_descr_;
extern const TTCN_Typedescriptor_t ResourceData_cName_descr_;
extern const TTCN_Typedescriptor_t RDataMB_descr_;
extern const TTCN_Typedescriptor_t ResourceData_mb_descr_;
extern const TTCN_Typedescriptor_t RDataMD_descr_;
extern const TTCN_Typedescriptor_t ResourceData_md_descr_;
extern const TTCN_Typedescriptor_t RDataMF_descr_;
extern const TTCN_Typedescriptor_t ResourceData_mf_descr_;
extern const TTCN_Typedescriptor_t RDataMG_descr_;
extern const TTCN_Typedescriptor_t ResourceData_mg_descr_;
extern const TTCN_Typedescriptor_t RDataMR_descr_;
extern const TTCN_Typedescriptor_t ResourceData_mr_descr_;
extern const TTCN_Typedescriptor_t RDataNull_descr_;
extern const TTCN_Typedescriptor_t ResourceData_rd__null_descr_;
extern const TTCN_Typedescriptor_t RDataNS_descr_;
extern const TTCN_Typedescriptor_t ResourceData_ns_descr_;
extern const TTCN_Typedescriptor_t RDataPTR_descr_;
extern const TTCN_Typedescriptor_t ResourceData_ptr_descr_;
extern const TTCN_Typedescriptor_t RDataA_descr_;
extern const TTCN_Typedescriptor_t ResourceData_a_descr_;
extern const TTCN_RAWdescriptor_t RDataAAAA_raw_;
extern const TTCN_Typedescriptor_t RDataAAAA_descr_;
extern const TTCN_Typedescriptor_t ResourceData_aaaa_descr_;
extern const TTCN_Typedescriptor_t ResourceData_unsupported_descr_;
extern const TTCN_Typedescriptor_t ResourceData_undecodable_descr_;
extern const TTCN_Typedescriptor_t ResourceRecord_descr_;
extern const INTEGER& DNS__A;
extern const INTEGER& DNS__NS;
extern const INTEGER& DNS__MD;
extern const INTEGER& DNS__MF;
extern const INTEGER& DNS__CNAME;
extern const INTEGER& DNS__SOA;
extern const INTEGER& DNS__MB;
extern const INTEGER& DNS__MG;
extern const INTEGER& DNS__MR;
extern const INTEGER& DNS__NULL;
extern const INTEGER& DNS__WKS;
extern const INTEGER& DNS__PTR;
extern const INTEGER& DNS__HINFO;
extern const INTEGER& DNS__MINFO;
extern const INTEGER& DNS__MX;
extern const INTEGER& DNS__TXT;
extern const INTEGER& DNS__AAAA;
extern const INTEGER& DNS__SRV;
extern const INTEGER& DNS__NAPTR;
extern const INTEGER& DNS__AXFR;
extern const INTEGER& DNS__MAILB;
extern const INTEGER& DNS__MAILA;
extern const INTEGER& DNS__ALLRECORDS;
extern const INTEGER& DNS__IN;
extern const INTEGER& DNS__CS;
extern const INTEGER& DNS__CH;
extern const INTEGER& DNS__HS;
extern const INTEGER& DNS__ANYCLASS;
extern const INTEGER& DNS__NONE;
extern const TTCN_Typedescriptor_t RDataHInfo_cpu_descr_;
extern const TTCN_Typedescriptor_t RDataHInfo_os_descr_;
extern const TTCN_Typedescriptor_t RDataHInfo_descr_;
extern const TTCN_Typedescriptor_t RDataMInfo_rMailBx_descr_;
extern const TTCN_Typedescriptor_t RDataMInfo_eMailBx_descr_;
extern const TTCN_Typedescriptor_t RDataMInfo_descr_;
extern const TTCN_Typedescriptor_t RDataMX_preference_descr_;
extern const TTCN_Typedescriptor_t RDataMX_exchange_descr_;
extern const TTCN_Typedescriptor_t RDataMX_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_mName_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_rName_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_serial_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_refresh_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_retry_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_expire_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_minimum_descr_;
extern const TTCN_Typedescriptor_t RDataSOA_descr_;
extern const TTCN_Typedescriptor_t RDataTXT_descr_;
extern const TTCN_Typedescriptor_t RDataTXT_0_descr_;
extern const TTCN_Typedescriptor_t RDataWKS_addr_descr_;
extern const TTCN_Typedescriptor_t UInt8_descr_;
extern const TTCN_Typedescriptor_t RDataWKS_protocol_descr_;
extern const TTCN_Typedescriptor_t RDataWKS_bitmap_descr_;
extern const TTCN_Typedescriptor_t RDataWKS_descr_;
extern const TTCN_Typedescriptor_t RDataSRV_priority_descr_;
extern const TTCN_Typedescriptor_t RDataSRV_weight_descr_;
extern const TTCN_Typedescriptor_t RDataSRV_portnum_descr_;
extern const TTCN_Typedescriptor_t RDataSRV_target_descr_;
extern const TTCN_Typedescriptor_t RDataSRV_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_order_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_preference_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_flags_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_services_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_regexpString_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_replacement_descr_;
extern const TTCN_Typedescriptor_t RDataNAPTR_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
