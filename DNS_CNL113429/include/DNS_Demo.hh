// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for Yann Garcia (yann@Ubuntu64) on Wed Feb 15 15:41:26 2017

// Copyright (c) 2000-2016 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef DNS__Demo_HH
#define DNS__Demo_HH

#ifndef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated with -R option but -DTITAN_RUNTIME_2 was not used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "DNS_Mapping.hh"

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef DNS__Demo_HH
#endif

namespace DNS__Demo {

/* Forward declarations of classes */

class PtrAssignment;
class PtrAssignment_template;
class AddrAssignment;
class AddrAssignment_template;
class SrvAssignment;
class SrvAssignment_template;
class NaptrAssignment;
class NaptrAssignment_template;
class PtrAssignments;
class PtrAssignments_template;
class AddrAssignments;
class AddrAssignments_template;
class SrvAssignments;
class SrvAssignments_template;
class NaptrAssignments;
class NaptrAssignments_template;

} /* end of namespace */

#ifndef DNS__Demo_HH
#define DNS__Demo_HH

namespace DNS__Demo {

/* Type definitions */

typedef COMPONENT Test__CT;
typedef COMPONENT_template Test__CT_template;

/* Class definitions */

class PtrAssignment : public Record_Type {
  CHARSTRING field_name;
  CHARSTRING field_ptr;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  PtrAssignment();
  PtrAssignment(const PtrAssignment& other_value);
  PtrAssignment(const CHARSTRING& par_name,
    const CHARSTRING& par_ptr);
inline PtrAssignment& operator=(const PtrAssignment& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PtrAssignment& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const PtrAssignment& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline CHARSTRING& ptr()
    {return field_ptr;}
  inline const CHARSTRING& ptr() const
    {return field_ptr;}
Base_Type* clone() const { return new PtrAssignment(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class PtrAssignment_template : public Record_Template {
void set_specific();
public:
PtrAssignment_template(): Record_Template() {}
PtrAssignment_template(template_sel other_value): Record_Template(other_value) {}
PtrAssignment_template(const PtrAssignment& other_value): Record_Template() { copy_value(&other_value); }
PtrAssignment_template(const OPTIONAL<PtrAssignment>& other_value): Record_Template() { copy_optional(&other_value); }
PtrAssignment_template(const PtrAssignment_template& other_value): Record_Template() { copy_template(other_value); }
PtrAssignment_template& operator=(template_sel other_value);
PtrAssignment_template& operator=(const PtrAssignment& other_value);
PtrAssignment_template& operator=(const OPTIONAL<PtrAssignment>& other_value);
PtrAssignment_template& operator=(const PtrAssignment_template& other_value);
inline boolean match(const PtrAssignment& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const PtrAssignment& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
PtrAssignment valueof() const;
inline PtrAssignment_template& list_item(int list_index) const { return *(static_cast<PtrAssignment_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
CHARSTRING_template& ptr();
const CHARSTRING_template& ptr() const;
Record_Template* create() const { return new PtrAssignment_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class AddrAssignment : public Record_Type {
  CHARSTRING field_name;
  OCTETSTRING field_ipAddr;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  AddrAssignment();
  AddrAssignment(const AddrAssignment& other_value);
  AddrAssignment(const CHARSTRING& par_name,
    const OCTETSTRING& par_ipAddr);
inline AddrAssignment& operator=(const AddrAssignment& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const AddrAssignment& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const AddrAssignment& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline OCTETSTRING& ipAddr()
    {return field_ipAddr;}
  inline const OCTETSTRING& ipAddr() const
    {return field_ipAddr;}
Base_Type* clone() const { return new AddrAssignment(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class AddrAssignment_template : public Record_Template {
void set_specific();
public:
AddrAssignment_template(): Record_Template() {}
AddrAssignment_template(template_sel other_value): Record_Template(other_value) {}
AddrAssignment_template(const AddrAssignment& other_value): Record_Template() { copy_value(&other_value); }
AddrAssignment_template(const OPTIONAL<AddrAssignment>& other_value): Record_Template() { copy_optional(&other_value); }
AddrAssignment_template(const AddrAssignment_template& other_value): Record_Template() { copy_template(other_value); }
AddrAssignment_template& operator=(template_sel other_value);
AddrAssignment_template& operator=(const AddrAssignment& other_value);
AddrAssignment_template& operator=(const OPTIONAL<AddrAssignment>& other_value);
AddrAssignment_template& operator=(const AddrAssignment_template& other_value);
inline boolean match(const AddrAssignment& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const AddrAssignment& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
AddrAssignment valueof() const;
inline AddrAssignment_template& list_item(int list_index) const { return *(static_cast<AddrAssignment_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
OCTETSTRING_template& ipAddr();
const OCTETSTRING_template& ipAddr() const;
Record_Template* create() const { return new AddrAssignment_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class SrvAssignment : public Record_Type {
  CHARSTRING field_name;
  DNS__Types::RDataSRV field_srv;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  SrvAssignment();
  SrvAssignment(const SrvAssignment& other_value);
  SrvAssignment(const CHARSTRING& par_name,
    const DNS__Types::RDataSRV& par_srv);
inline SrvAssignment& operator=(const SrvAssignment& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const SrvAssignment& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const SrvAssignment& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline DNS__Types::RDataSRV& srv()
    {return field_srv;}
  inline const DNS__Types::RDataSRV& srv() const
    {return field_srv;}
Base_Type* clone() const { return new SrvAssignment(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class SrvAssignment_template : public Record_Template {
void set_specific();
public:
SrvAssignment_template(): Record_Template() {}
SrvAssignment_template(template_sel other_value): Record_Template(other_value) {}
SrvAssignment_template(const SrvAssignment& other_value): Record_Template() { copy_value(&other_value); }
SrvAssignment_template(const OPTIONAL<SrvAssignment>& other_value): Record_Template() { copy_optional(&other_value); }
SrvAssignment_template(const SrvAssignment_template& other_value): Record_Template() { copy_template(other_value); }
SrvAssignment_template& operator=(template_sel other_value);
SrvAssignment_template& operator=(const SrvAssignment& other_value);
SrvAssignment_template& operator=(const OPTIONAL<SrvAssignment>& other_value);
SrvAssignment_template& operator=(const SrvAssignment_template& other_value);
inline boolean match(const SrvAssignment& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const SrvAssignment& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
SrvAssignment valueof() const;
inline SrvAssignment_template& list_item(int list_index) const { return *(static_cast<SrvAssignment_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
DNS__Types::RDataSRV_template& srv();
const DNS__Types::RDataSRV_template& srv() const;
Record_Template* create() const { return new SrvAssignment_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class NaptrAssignment : public Record_Type {
  CHARSTRING field_name;
  DNS__Types::RDataNAPTR field_naptr;
  Base_Type* fld_vec[2];
  void init_vec();
public:
  NaptrAssignment();
  NaptrAssignment(const NaptrAssignment& other_value);
  NaptrAssignment(const CHARSTRING& par_name,
    const DNS__Types::RDataNAPTR& par_naptr);
inline NaptrAssignment& operator=(const NaptrAssignment& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const NaptrAssignment& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const NaptrAssignment& other_value) const
    { return !is_equal(&other_value); }

  inline CHARSTRING& name()
    {return field_name;}
  inline const CHARSTRING& name() const
    {return field_name;}
  inline DNS__Types::RDataNAPTR& naptr()
    {return field_naptr;}
  inline const DNS__Types::RDataNAPTR& naptr() const
    {return field_naptr;}
Base_Type* clone() const { return new NaptrAssignment(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 2; }
boolean default_as_optional() const { return TRUE; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class NaptrAssignment_template : public Record_Template {
void set_specific();
public:
NaptrAssignment_template(): Record_Template() {}
NaptrAssignment_template(template_sel other_value): Record_Template(other_value) {}
NaptrAssignment_template(const NaptrAssignment& other_value): Record_Template() { copy_value(&other_value); }
NaptrAssignment_template(const OPTIONAL<NaptrAssignment>& other_value): Record_Template() { copy_optional(&other_value); }
NaptrAssignment_template(const NaptrAssignment_template& other_value): Record_Template() { copy_template(other_value); }
NaptrAssignment_template& operator=(template_sel other_value);
NaptrAssignment_template& operator=(const NaptrAssignment& other_value);
NaptrAssignment_template& operator=(const OPTIONAL<NaptrAssignment>& other_value);
NaptrAssignment_template& operator=(const NaptrAssignment_template& other_value);
inline boolean match(const NaptrAssignment& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const NaptrAssignment& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
NaptrAssignment valueof() const;
inline NaptrAssignment_template& list_item(int list_index) const { return *(static_cast<NaptrAssignment_template*>(get_list_item(list_index))); }
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
DNS__Types::RDataNAPTR_template& naptr();
const DNS__Types::RDataNAPTR_template& naptr() const;
Record_Template* create() const { return new NaptrAssignment_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class PtrAssignments : public Record_Of_Type {

static const PtrAssignment UNBOUND_ELEM;

public:
PtrAssignments(): Record_Of_Type() {}
PtrAssignments(null_type other_value): Record_Of_Type(other_value) {}
PtrAssignments(const PtrAssignments& other_value): Record_Of_Type(other_value) {}
~PtrAssignments() { clean_up(); }

inline PtrAssignments& operator=(null_type other_value) { set_val(other_value); return *this; }
inline PtrAssignments& operator=(const PtrAssignments& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const PtrAssignments& other_value) const { return is_equal(&other_value); }
boolean operator!=(const PtrAssignments& other_value) const { return !is_equal(&other_value); }
PtrAssignment& operator[](int index_value);
PtrAssignment& operator[](const INTEGER& index_value);
const PtrAssignment& operator[](int index_value) const;
const PtrAssignment& operator[](const INTEGER& index_value) const;
PtrAssignments operator<<=(int rotate_count) const;
PtrAssignments operator<<=(const INTEGER& rotate_count) const;
PtrAssignments operator>>=(int rotate_count) const;
PtrAssignments operator>>=(const INTEGER& rotate_count) const;

PtrAssignments operator+(const PtrAssignments& other_value) const;

PtrAssignments substr(int index, int returncount) const;

PtrAssignments replace(int index, int len, const PtrAssignments& repl) const;

PtrAssignments replace(int index, int len, const PtrAssignments_template& repl) const;

Base_Type* clone() const { return new PtrAssignments(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
virtual boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int) { return FALSE; }
};

class PtrAssignments_template : public Record_Of_Template {

public:
PtrAssignments_template() {}
PtrAssignments_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
PtrAssignments_template(null_type other_value);
PtrAssignments_template(const PtrAssignments& other_value) { copy_value(&other_value); }
PtrAssignments_template(const OPTIONAL<PtrAssignments>& other_value) { copy_optional(&other_value); }
PtrAssignments_template(const PtrAssignments_template& other_value): Record_Of_Template() { copy_template(other_value); }
PtrAssignments_template& operator=(template_sel other_value);
PtrAssignments_template& operator=(null_type other_value);
PtrAssignments_template& operator=(const PtrAssignments& other_value);
PtrAssignments_template& operator=(const OPTIONAL<PtrAssignments>& other_value);
PtrAssignments_template& operator=(const PtrAssignments_template& other_value);

PtrAssignment_template& operator[](int index_value);
PtrAssignment_template& operator[](const INTEGER& index_value);
const PtrAssignment_template& operator[](int index_value) const;
const PtrAssignment_template& operator[](const INTEGER& index_value) const;
inline boolean match(const PtrAssignments& match_value, boolean legacy = FALSE) const { return matchv(&match_value, legacy); }
PtrAssignments valueof() const;
PtrAssignments substr(int index, int returncount) const;

PtrAssignments replace(int index, int len, const PtrAssignments_template& repl) const;

PtrAssignments replace(int index, int len, const PtrAssignments& repl) const;

inline PtrAssignments_template& list_item(int list_index) { return *(static_cast<PtrAssignments_template*>(get_list_item(list_index))); }
inline void log_match(const PtrAssignments& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
Record_Of_Template* create() const { return new PtrAssignments_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class AddrAssignments : public Record_Of_Type {

static const AddrAssignment UNBOUND_ELEM;

public:
AddrAssignments(): Record_Of_Type() {}
AddrAssignments(null_type other_value): Record_Of_Type(other_value) {}
AddrAssignments(const AddrAssignments& other_value): Record_Of_Type(other_value) {}
~AddrAssignments() { clean_up(); }

inline AddrAssignments& operator=(null_type other_value) { set_val(other_value); return *this; }
inline AddrAssignments& operator=(const AddrAssignments& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const AddrAssignments& other_value) const { return is_equal(&other_value); }
boolean operator!=(const AddrAssignments& other_value) const { return !is_equal(&other_value); }
AddrAssignment& operator[](int index_value);
AddrAssignment& operator[](const INTEGER& index_value);
const AddrAssignment& operator[](int index_value) const;
const AddrAssignment& operator[](const INTEGER& index_value) const;
AddrAssignments operator<<=(int rotate_count) const;
AddrAssignments operator<<=(const INTEGER& rotate_count) const;
AddrAssignments operator>>=(int rotate_count) const;
AddrAssignments operator>>=(const INTEGER& rotate_count) const;

AddrAssignments operator+(const AddrAssignments& other_value) const;

AddrAssignments substr(int index, int returncount) const;

AddrAssignments replace(int index, int len, const AddrAssignments& repl) const;

AddrAssignments replace(int index, int len, const AddrAssignments_template& repl) const;

Base_Type* clone() const { return new AddrAssignments(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
virtual boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int) { return FALSE; }
};

class AddrAssignments_template : public Record_Of_Template {

public:
AddrAssignments_template() {}
AddrAssignments_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
AddrAssignments_template(null_type other_value);
AddrAssignments_template(const AddrAssignments& other_value) { copy_value(&other_value); }
AddrAssignments_template(const OPTIONAL<AddrAssignments>& other_value) { copy_optional(&other_value); }
AddrAssignments_template(const AddrAssignments_template& other_value): Record_Of_Template() { copy_template(other_value); }
AddrAssignments_template& operator=(template_sel other_value);
AddrAssignments_template& operator=(null_type other_value);
AddrAssignments_template& operator=(const AddrAssignments& other_value);
AddrAssignments_template& operator=(const OPTIONAL<AddrAssignments>& other_value);
AddrAssignments_template& operator=(const AddrAssignments_template& other_value);

AddrAssignment_template& operator[](int index_value);
AddrAssignment_template& operator[](const INTEGER& index_value);
const AddrAssignment_template& operator[](int index_value) const;
const AddrAssignment_template& operator[](const INTEGER& index_value) const;
inline boolean match(const AddrAssignments& match_value, boolean legacy = FALSE) const { return matchv(&match_value, legacy); }
AddrAssignments valueof() const;
AddrAssignments substr(int index, int returncount) const;

AddrAssignments replace(int index, int len, const AddrAssignments_template& repl) const;

AddrAssignments replace(int index, int len, const AddrAssignments& repl) const;

inline AddrAssignments_template& list_item(int list_index) { return *(static_cast<AddrAssignments_template*>(get_list_item(list_index))); }
inline void log_match(const AddrAssignments& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
Record_Of_Template* create() const { return new AddrAssignments_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class SrvAssignments : public Record_Of_Type {

static const SrvAssignment UNBOUND_ELEM;

public:
SrvAssignments(): Record_Of_Type() {}
SrvAssignments(null_type other_value): Record_Of_Type(other_value) {}
SrvAssignments(const SrvAssignments& other_value): Record_Of_Type(other_value) {}
~SrvAssignments() { clean_up(); }

inline SrvAssignments& operator=(null_type other_value) { set_val(other_value); return *this; }
inline SrvAssignments& operator=(const SrvAssignments& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const SrvAssignments& other_value) const { return is_equal(&other_value); }
boolean operator!=(const SrvAssignments& other_value) const { return !is_equal(&other_value); }
SrvAssignment& operator[](int index_value);
SrvAssignment& operator[](const INTEGER& index_value);
const SrvAssignment& operator[](int index_value) const;
const SrvAssignment& operator[](const INTEGER& index_value) const;
SrvAssignments operator<<=(int rotate_count) const;
SrvAssignments operator<<=(const INTEGER& rotate_count) const;
SrvAssignments operator>>=(int rotate_count) const;
SrvAssignments operator>>=(const INTEGER& rotate_count) const;

SrvAssignments operator+(const SrvAssignments& other_value) const;

SrvAssignments substr(int index, int returncount) const;

SrvAssignments replace(int index, int len, const SrvAssignments& repl) const;

SrvAssignments replace(int index, int len, const SrvAssignments_template& repl) const;

Base_Type* clone() const { return new SrvAssignments(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
virtual boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int) { return FALSE; }
};

class SrvAssignments_template : public Record_Of_Template {

public:
SrvAssignments_template() {}
SrvAssignments_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
SrvAssignments_template(null_type other_value);
SrvAssignments_template(const SrvAssignments& other_value) { copy_value(&other_value); }
SrvAssignments_template(const OPTIONAL<SrvAssignments>& other_value) { copy_optional(&other_value); }
SrvAssignments_template(const SrvAssignments_template& other_value): Record_Of_Template() { copy_template(other_value); }
SrvAssignments_template& operator=(template_sel other_value);
SrvAssignments_template& operator=(null_type other_value);
SrvAssignments_template& operator=(const SrvAssignments& other_value);
SrvAssignments_template& operator=(const OPTIONAL<SrvAssignments>& other_value);
SrvAssignments_template& operator=(const SrvAssignments_template& other_value);

SrvAssignment_template& operator[](int index_value);
SrvAssignment_template& operator[](const INTEGER& index_value);
const SrvAssignment_template& operator[](int index_value) const;
const SrvAssignment_template& operator[](const INTEGER& index_value) const;
inline boolean match(const SrvAssignments& match_value, boolean legacy = FALSE) const { return matchv(&match_value, legacy); }
SrvAssignments valueof() const;
SrvAssignments substr(int index, int returncount) const;

SrvAssignments replace(int index, int len, const SrvAssignments_template& repl) const;

SrvAssignments replace(int index, int len, const SrvAssignments& repl) const;

inline SrvAssignments_template& list_item(int list_index) { return *(static_cast<SrvAssignments_template*>(get_list_item(list_index))); }
inline void log_match(const SrvAssignments& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
Record_Of_Template* create() const { return new SrvAssignments_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};

class NaptrAssignments : public Record_Of_Type {

static const NaptrAssignment UNBOUND_ELEM;

public:
NaptrAssignments(): Record_Of_Type() {}
NaptrAssignments(null_type other_value): Record_Of_Type(other_value) {}
NaptrAssignments(const NaptrAssignments& other_value): Record_Of_Type(other_value) {}
~NaptrAssignments() { clean_up(); }

inline NaptrAssignments& operator=(null_type other_value) { set_val(other_value); return *this; }
inline NaptrAssignments& operator=(const NaptrAssignments& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const NaptrAssignments& other_value) const { return is_equal(&other_value); }
boolean operator!=(const NaptrAssignments& other_value) const { return !is_equal(&other_value); }
NaptrAssignment& operator[](int index_value);
NaptrAssignment& operator[](const INTEGER& index_value);
const NaptrAssignment& operator[](int index_value) const;
const NaptrAssignment& operator[](const INTEGER& index_value) const;
NaptrAssignments operator<<=(int rotate_count) const;
NaptrAssignments operator<<=(const INTEGER& rotate_count) const;
NaptrAssignments operator>>=(int rotate_count) const;
NaptrAssignments operator>>=(const INTEGER& rotate_count) const;

NaptrAssignments operator+(const NaptrAssignments& other_value) const;

NaptrAssignments substr(int index, int returncount) const;

NaptrAssignments replace(int index, int len, const NaptrAssignments& repl) const;

NaptrAssignments replace(int index, int len, const NaptrAssignments_template& repl) const;

Base_Type* clone() const { return new NaptrAssignments(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
const TTCN_Typedescriptor_t* get_elem_descr() const;
Base_Type* create_elem() const;
const Base_Type* get_unbound_elem() const;
boolean is_set() const { return FALSE; }
virtual boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int) { return FALSE; }
};

class NaptrAssignments_template : public Record_Of_Template {

public:
NaptrAssignments_template() {}
NaptrAssignments_template(template_sel other_value): Record_Of_Template(other_value) { check_single_selection(other_value); }
NaptrAssignments_template(null_type other_value);
NaptrAssignments_template(const NaptrAssignments& other_value) { copy_value(&other_value); }
NaptrAssignments_template(const OPTIONAL<NaptrAssignments>& other_value) { copy_optional(&other_value); }
NaptrAssignments_template(const NaptrAssignments_template& other_value): Record_Of_Template() { copy_template(other_value); }
NaptrAssignments_template& operator=(template_sel other_value);
NaptrAssignments_template& operator=(null_type other_value);
NaptrAssignments_template& operator=(const NaptrAssignments& other_value);
NaptrAssignments_template& operator=(const OPTIONAL<NaptrAssignments>& other_value);
NaptrAssignments_template& operator=(const NaptrAssignments_template& other_value);

NaptrAssignment_template& operator[](int index_value);
NaptrAssignment_template& operator[](const INTEGER& index_value);
const NaptrAssignment_template& operator[](int index_value) const;
const NaptrAssignment_template& operator[](const INTEGER& index_value) const;
inline boolean match(const NaptrAssignments& match_value, boolean legacy = FALSE) const { return matchv(&match_value, legacy); }
NaptrAssignments valueof() const;
NaptrAssignments substr(int index, int returncount) const;

NaptrAssignments replace(int index, int len, const NaptrAssignments_template& repl) const;

NaptrAssignments replace(int index, int len, const NaptrAssignments& repl) const;

inline NaptrAssignments_template& list_item(int list_index) { return *(static_cast<NaptrAssignments_template*>(get_list_item(list_index))); }
inline void log_match(const NaptrAssignments& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
Record_Of_Template* create() const { return new NaptrAssignments_template; }
Base_Template* create_elem() const;
const TTCN_Typedescriptor_t* get_descriptor() const;
};


/* Function prototypes */

extern DNS__Mapping::ASP__UDP__DNS_template tr__DNS__srv__nameparam(const CHARSTRING& pl__name);
extern DNS__Mapping::ASP__UDP__DNS_template tr__DNS__naptr__nameparam(const CHARSTRING& pl__name);
extern DNS__Mapping::ASP__UDP__DNS_template tr__DNS__naptr__answer(const CHARSTRING& pl__name);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__ptr(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg, const CHARSTRING& pl__answer, const BOOLEAN& pl__compress);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__address(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg, const OCTETSTRING& pl__answer, const BOOLEAN& pl__compress);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__nameError(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__srv__answer(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg, const DNS__Types::RDataSRV& pl__answer, const BOOLEAN& pl__compress);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__srv__3__answers(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg, const DNS__Types::RDataSRV& pl__answer1, const DNS__Types::RDataSRV& pl__answer2, const DNS__Types::RDataSRV& pl__answer3, const BOOLEAN& pl__compress);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__naptr__3__answers(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg, const DNS__Types::RDataNAPTR& pl__answer1, const DNS__Types::RDataNAPTR& pl__answer2, const DNS__Types::RDataNAPTR& pl__answer3, const BOOLEAN& pl__compress);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__naptr__answer(const DNS__Mapping::ASP__UDP__DNS& pl__rmsg, const DNS__Types::RDataNAPTR& pl__answer, const BOOLEAN& pl__compress);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__NAPTRquery(const CHARSTRING& pl__ipAddr, const CHARSTRING& pl__query);
extern DNS__Mapping::ASP__UDP__DNS_template t__DNS__SRVquery(const CHARSTRING& pl__ipAddr, const CHARSTRING& pl__query);
extern verdicttype testcase_tc__1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__srv__naptr(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__multiple__srv__naptr(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__enumquery(boolean has_timer, double timer_value);

/* Global variable declarations */

extern const TTCN_Typedescriptor_t PtrAssignment_name_descr_;
extern const TTCN_Typedescriptor_t PtrAssignment_ptr_descr_;
extern const TTCN_Typedescriptor_t PtrAssignment_descr_;
extern const TTCN_Typedescriptor_t AddrAssignment_name_descr_;
extern const TTCN_Typedescriptor_t AddrAssignment_ipAddr_descr_;
extern const TTCN_Typedescriptor_t AddrAssignment_descr_;
extern const TTCN_Typedescriptor_t SrvAssignment_name_descr_;
extern const TTCN_Typedescriptor_t SrvAssignment_descr_;
extern const TTCN_Typedescriptor_t NaptrAssignment_name_descr_;
extern const TTCN_Typedescriptor_t NaptrAssignment_descr_;
extern const TTCN_Typedescriptor_t PtrAssignments_descr_;
extern const TTCN_Typedescriptor_t AddrAssignments_descr_;
extern const TTCN_Typedescriptor_t SrvAssignments_descr_;
extern const TTCN_Typedescriptor_t NaptrAssignments_descr_;
extern const TTCN_Typedescriptor_t& Test__CT_descr_;
extern DNS__Mapping::UDPasp__DNS__SP__PT Test__CT_component_UDP__DNS__PCO;
extern const FLOAT& cg__tcTimeout;
extern const PtrAssignments& cg__ptrAssignments;
extern const AddrAssignments& cg__addrAssignments;
extern const SrvAssignments& cg__srvAssignments;
extern const NaptrAssignments& cg__naptrAssignments;
extern const DNS__Mapping::ASP__UDP__DNS_template& tr__DNS__ptr;
extern const DNS__Mapping::ASP__UDP__DNS_template& tr__DNS__address;
extern const DNS__Mapping::ASP__UDP__DNS_template& tr__DNS__srv;
extern const DNS__Mapping::ASP__UDP__DNS_template& tr__DNS__naptr;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
