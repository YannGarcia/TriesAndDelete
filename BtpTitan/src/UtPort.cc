// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for U-ERICSSON\ethgry (ethgry@HU00078339) on Fri Aug 14 21:19:06 2015

// Copyright Ericsson Telecom AB 2000-2014

// You may modify this file. Complete the body of empty functions and
// add your member functions here.

#include "UtPort.hh"

#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <memory.h>

namespace Btp__TestSystem {

  UtPort::UtPort(const char *par_port_name) :
      UtPort_BASE(par_port_name), is_port_mapped(false), debugging(true), target_fd(-1) {

  }

  UtPort::~UtPort() {
    if (is_port_mapped) {
      close_socket();
      Uninstall_Handler();
    }
  }

  void UtPort::set_parameter(const char * parameter_name, const char * parameter_value) {
    log("entering UtPort::set_parameter(%s, %s)", parameter_name, parameter_value);

    // TODO

    log("leaving UtPort::set_parameter(%s, %s)", parameter_name, parameter_value);
  }

  void UtPort::Event_Handler(const fd_set *read_fds, const fd_set */*write_fds*/, const fd_set */*error_fds*/, double /*time_since_last_call*/) {

    log("entering UtPort::Event_Handler()");

    // TODO

    log("leaving UtPort::Event_Handler()");
  }

  void UtPort::Handle_Fd_Event_Error(int /*fd*/) {

  }

  void UtPort::Handle_Fd_Event_Writable(int /*fd*/) {

  }

  void UtPort::Handle_Fd_Event_Readable(int /*fd*/) {

  }

  /*void UtPort::Handle_Timeout(double time_since_last_call) {}*/

  void UtPort::user_map(const char * /*system_port*/) {
    // TODO
    is_port_mapped = true;
  }

  void UtPort::user_unmap(const char * /*system_port*/) {
    is_port_mapped = false;
  }

  void UtPort::user_start() {

  }

  void UtPort::user_stop() {

  }

  void UtPort::outgoing_send(const Ut__TypesAndValues::UtInitialize& send_par) {
    log("entering UtPort::outgoing_send");

    // TODO

    log("leaving UtPort::outgoing_send");
  }

  void UtPort::init_socket() {
    log("entering UtPort::init_socket()");

    /* socket creation */
    if ((target_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
      TTCN_error("Cannot open socket \n");
    }

    log("Binding port...");
    if (bind(target_fd, (struct sockaddr *) &local_address, sizeof(local_address)) < 0) {
      TTCN_error("Cannot bind port\n");
    }

    log("leaving UtPort::init_socket()");
  }

  void UtPort::close_socket() {
    log("entering UtPort::close_socket()");
    close(target_fd);
    target_fd = -1;
    log("entering UtPort::close_socket()");
  }

  void UtPort::log(const char *fmt, ...) {
    if (debugging) {
      TTCN_Logger::begin_event (TTCN_DEBUG);
      TTCN_Logger::log_event("UDP test port (%s): ", get_name());
      va_list args;
      va_start(args, fmt);
      TTCN_Logger::log_event_va_list(fmt, args);
      va_end(args);
      TTCN_Logger::end_event();
    }
  }

  void UtPort::logHex(const char *prompt, const OCTETSTRING& msg) {
    if (debugging) { //if debug
      TTCN_Logger::begin_event (TTCN_DEBUG);
      TTCN_Logger::log_event_str(prompt);
      TTCN_Logger::log_event("Size: %d,\nMsg: ", msg.lengthof());

      for (int i = 0; i < msg.lengthof(); i++)
        TTCN_Logger::log_event(" %02x", ((const unsigned char*) msg)[i]);
      TTCN_Logger::log_event("\n");
      TTCN_Logger::end_event();
    }
  }

  unsigned long UtPort::get_host_id(const char* host_name) {
    log("UtPort::get_host_id called");
    unsigned long ipAddress = 0;

    if (strcmp(host_name, "255.255.255.255") == 0) {
      ipAddress = 0xffffffff;
    } else {
      in_addr_t addr = inet_addr(host_name);
      if (addr != (in_addr_t) - 1) {   // host name in XX:XX:XX:XX form
        ipAddress = addr;
      } else {               // host name in domain.com form
        struct hostent* hptr;
        if ((hptr = gethostbyname(host_name)) == 0)
          TTCN_error("The host name %s is not valid.", host_name);
        ipAddress = *((unsigned long*) hptr->h_addr_list[0]);
      }
    }

    log("Host name: %s, Host address: %u", (const char*) host_name, ipAddress);
    log("UtPort::get_host_id exited");

    return htonl(ipAddress);
  }

} /* end of namespace */

