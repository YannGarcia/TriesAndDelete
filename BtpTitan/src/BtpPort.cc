// This Test Port skeleton source file was generated by the
// TTCN-3 Compiler of the TTCN-3 Test Executor version CRL 113 200/5 R3A
// for U-ERICSSON\ethgry (ethgry@HU00078339) on Fri Aug 14 21:19:06 2015

// Copyright Ericsson Telecom AB 2000-2014

// You may modify this file. Complete the body of empty functions and
// add your member functions here.

#include "BtpPort.hh"

#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <memory.h>

namespace Btp__TestSystem {

  BtpPort::BtpPort(const char *par_port_name) :
      BtpPort_BASE(par_port_name), is_port_mapped(false), debugging(true), target_fd(-1) {

  }

  BtpPort::~BtpPort() {
    if (is_port_mapped) {
      close_socket();
      Uninstall_Handler();
    }
  }

  void BtpPort::set_parameter(const char * parameter_name, const char * parameter_value) {
    log("entering BtpPort::set_parameter(%s, %s)", parameter_name, parameter_value);
    local_address.sin_family = AF_INET;
    local_address.sin_addr.s_addr = INADDR_ANY;
    if (!strcmp(parameter_name, "debugging")) {
      if (!strcmp(parameter_value, "YES") || !strcmp(parameter_value, "yes"))
        debugging = true;
    } else if (!strcmp(parameter_name, "localPort")) {
      local_address.sin_port = htons(atoi(parameter_value));
    } else {
      TTCN_warning("BtpPort::set_parameter(): Unsupported Test Port parameter: %s", parameter_name);
    }
    log("leaving BtpPort::set_parameter(%s, %s)", parameter_name, parameter_value);
  }

  void BtpPort::Event_Handler(const fd_set *read_fds, const fd_set */*write_fds*/, const fd_set */*error_fds*/, double /*time_since_last_call*/) {

    log("entering BtpPort::Event_Handler()");
    unsigned char msg[65535];     // Allocate memory for possible messages
    int msgLength;
    struct sockaddr_in remoteAddr;
    socklen_t addr_length = sizeof(remoteAddr);

    if ((msgLength = recvfrom(target_fd, (char*) msg, sizeof(msg), 0, (struct sockaddr*) &remoteAddr, &addr_length)) < 0)
      TTCN_error("Error when reading the received UDP PDU.");

    logHex("Message received:  ", OCTETSTRING(msgLength, msg));
    log("The remote port:      %d", remoteAddr.sin_port);
    char *remote_address = inet_ntoa(remoteAddr.sin_addr);
    log("The remote address:     %s", remote_address);

    logHex("Received PDU   ", OCTETSTRING(msgLength, msg));

    BtpInd pdu;
    TTCN_Buffer buffer(OCTETSTRING(msgLength, msg));
    pdu.decode(*pdu.get_descriptor(), buffer, TTCN_EncDec::CT_RAW);
    incoming_message(pdu);

    log("leaving BtpPort::Event_Handler()");
  }

  void BtpPort::Handle_Fd_Event_Error(int /*fd*/) {

  }

  void BtpPort::Handle_Fd_Event_Writable(int /*fd*/) {

  }

  void BtpPort::Handle_Fd_Event_Readable(int /*fd*/) {

  }

  /*void BtpPort::Handle_Timeout(double time_since_last_call) {}*/

  void BtpPort::user_map(const char * /*system_port*/) {
    if (!is_port_mapped) {
      init_socket();
      fd_set readfds;
      FD_ZERO(&readfds);
      FD_SET(target_fd, &readfds);
      Install_Handler(&readfds, NULL, NULL, 0.0);
      is_port_mapped = true;
    }
  }

  void BtpPort::user_unmap(const char * /*system_port*/) {
    is_port_mapped = false;
    close_socket();
    Uninstall_Handler();
  }

  void BtpPort::user_start() {

  }

  void BtpPort::user_stop() {

  }

  void BtpPort::outgoing_send(const BtpReq& /*send_par*/) {

  }

  void BtpPort::init_socket() {
    log("entering BtpPort::init_socket()");

    /* socket creation */
    if ((target_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
      TTCN_error("Cannot open socket \n");
    }

    log("Binding port...");
    if (bind(target_fd, (struct sockaddr *) &local_address, sizeof(local_address)) < 0) {
      TTCN_error("Cannot bind port\n");
    }

    log("leaving BtpPort::init_socket()");
  }

  void BtpPort::close_socket() {
    log("entering BtpPort::close_socket()");
    close(target_fd);
    target_fd = -1;
    log("entering BtpPort::close_socket()");
  }

  void BtpPort::log(const char *fmt, ...) {
    if (debugging) {
      TTCN_Logger::begin_event (TTCN_DEBUG);
      TTCN_Logger::log_event("UDP test port (%s): ", get_name());
      va_list args;
      va_start(args, fmt);
      TTCN_Logger::log_event_va_list(fmt, args);
      va_end(args);
      TTCN_Logger::end_event();
    }
  }

  void BtpPort::logHex(const char *prompt, const OCTETSTRING& msg) {
    if (debugging) { //if debug
      TTCN_Logger::begin_event (TTCN_DEBUG);
      TTCN_Logger::log_event_str(prompt);
      TTCN_Logger::log_event("Size: %d,\nMsg: ", msg.lengthof());

      for (int i = 0; i < msg.lengthof(); i++)
        TTCN_Logger::log_event(" %02x", ((const unsigned char*) msg)[i]);
      TTCN_Logger::log_event("\n");
      TTCN_Logger::end_event();
    }
  }

  unsigned long BtpPort::get_host_id(const char* host_name) {
    log("BtpPort::get_host_id called");
    unsigned long ipAddress = 0;

    if (strcmp(host_name, "255.255.255.255") == 0) {
      ipAddress = 0xffffffff;
    } else {
      in_addr_t addr = inet_addr(host_name);
      if (addr != (in_addr_t) - 1) {   // host name in XX:XX:XX:XX form
        ipAddress = addr;
      } else {               // host name in domain.com form
        struct hostent* hptr;
        if ((hptr = gethostbyname(host_name)) == 0)
          TTCN_error("The host name %s is not valid.", host_name);
        ipAddress = *((unsigned long*) hptr->h_addr_list[0]);
      }
    }

    log("Host name: %s, Host address: %u", (const char*) host_name, ipAddress);
    log("BtpPort::get_host_id exited");

    return htonl(ipAddress);
  }

} /* end of namespace */

