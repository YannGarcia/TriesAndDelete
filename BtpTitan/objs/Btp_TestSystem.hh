// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for Yann Garcia (yann@Ubuntu64) on Tue Feb 28 11:22:01 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef Btp__TestSystem_HH
#define Btp__TestSystem_HH

#ifndef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated with -R option but -DTITAN_RUNTIME_2 was not used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "Btp_TypesAndValues.hh"

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef Btp__TestSystem_HH
#endif

namespace Btp__TestSystem {

/* Forward declarations of classes */

class BtpPort_BASE;
class BtpPort;
class BtpInd;
class BtpInd_template;
class BtpReq;
class BtpReq_template;

} /* end of namespace */

#ifndef Btp__TestSystem_HH
#define Btp__TestSystem_HH

namespace Btp__TestSystem {

/* Type definitions */

typedef COMPONENT ItsBtpSystem;
typedef COMPONENT_template ItsBtpSystem_template;
typedef COMPONENT ItsBtp;
typedef COMPONENT_template ItsBtp_template;

/* Class definitions */

class BtpPort_BASE : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
BtpInd *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
BtpPort_BASE(const char *par_port_name);
~BtpPort_BASE();
void send(const BtpReq& send_par, const COMPONENT& destination_component);
void send(const BtpReq& send_par);
void send(const BtpReq_template& send_par, const COMPONENT& destination_component);
void send(const BtpReq_template& send_par);
protected:
virtual void outgoing_send(const BtpReq& send_par) = 0;
public:
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const BtpInd_template& value_template, Value_Redirect_Interface *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const BtpInd_template& value_template, Value_Redirect_Interface *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const BtpInd_template& value_template, Value_Redirect_Interface *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const BtpInd& incoming_par, component sender_component);
protected:
inline void incoming_message(const BtpInd& incoming_par) { incoming_message(incoming_par, SYSTEM_COMPREF); }
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class BtpInd : public Record_Type {
  Btp__TypesAndValues::BtpPacket field_msgIn;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  BtpInd();
  BtpInd(const BtpInd& other_value);
  BtpInd(const Btp__TypesAndValues::BtpPacket& par_msgIn);
inline BtpInd& operator=(const BtpInd& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const BtpInd& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const BtpInd& other_value) const
    { return !is_equal(&other_value); }

  inline Btp__TypesAndValues::BtpPacket& msgIn()
    {return field_msgIn;}
  inline const Btp__TypesAndValues::BtpPacket& msgIn() const
    {return field_msgIn;}
Base_Type* clone() const { return new BtpInd(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class BtpInd_template : public Record_Template {
void set_specific();
public:
BtpInd_template(): Record_Template() {}
BtpInd_template(template_sel other_value): Record_Template(other_value) {}
BtpInd_template(const BtpInd& other_value): Record_Template() { copy_value(&other_value); }
BtpInd_template(const OPTIONAL<BtpInd>& other_value): Record_Template() { copy_optional(&other_value); }
BtpInd_template(const BtpInd_template& other_value): Record_Template() { copy_template(other_value); }
BtpInd_template& operator=(template_sel other_value);
BtpInd_template& operator=(const BtpInd& other_value);
BtpInd_template& operator=(const OPTIONAL<BtpInd>& other_value);
BtpInd_template& operator=(const BtpInd_template& other_value);
inline boolean match(const BtpInd& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const BtpInd& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
BtpInd valueof() const;
inline BtpInd_template& list_item(int list_index) const { return *(static_cast<BtpInd_template*>(get_list_item(list_index))); }
Btp__TypesAndValues::BtpPacket_template& msgIn();
const Btp__TypesAndValues::BtpPacket_template& msgIn() const;
Record_Template* create() const { return new BtpInd_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};

class BtpReq : public Record_Type {
  Btp__TypesAndValues::BtpPacket field_msgOut;
  Base_Type* fld_vec[1];
  void init_vec();
public:
  BtpReq();
  BtpReq(const BtpReq& other_value);
  BtpReq(const Btp__TypesAndValues::BtpPacket& par_msgOut);
inline BtpReq& operator=(const BtpReq& other_value) { set_value(&other_value); return *this; }

inline boolean operator==(const BtpReq& other_value) const { return is_equal(&other_value); }
  inline boolean operator!=(const BtpReq& other_value) const
    { return !is_equal(&other_value); }

  inline Btp__TypesAndValues::BtpPacket& msgOut()
    {return field_msgOut;}
  inline const Btp__TypesAndValues::BtpPacket& msgOut() const
    {return field_msgOut;}
Base_Type* clone() const { return new BtpReq(*this); }
const TTCN_Typedescriptor_t* get_descriptor() const;
boolean is_set() const { return FALSE; }
Base_Type* get_at(int index_value) { return fld_vec[index_value]; }
const Base_Type* get_at(int index_value) const { return fld_vec[index_value]; }

int get_count() const { return 1; }
static const TTCN_Typedescriptor_t* fld_descriptors[];
const TTCN_Typedescriptor_t* fld_descr(int p_index) const;

static const char* fld_names[];
const char* fld_name(int p_index) const;

boolean can_start_v(const char *, const char *, XERdescriptor_t const&, unsigned int, unsigned int)
{ return FALSE; }
};

class BtpReq_template : public Record_Template {
void set_specific();
public:
BtpReq_template(): Record_Template() {}
BtpReq_template(template_sel other_value): Record_Template(other_value) {}
BtpReq_template(const BtpReq& other_value): Record_Template() { copy_value(&other_value); }
BtpReq_template(const OPTIONAL<BtpReq>& other_value): Record_Template() { copy_optional(&other_value); }
BtpReq_template(const BtpReq_template& other_value): Record_Template() { copy_template(other_value); }
BtpReq_template& operator=(template_sel other_value);
BtpReq_template& operator=(const BtpReq& other_value);
BtpReq_template& operator=(const OPTIONAL<BtpReq>& other_value);
BtpReq_template& operator=(const BtpReq_template& other_value);
inline boolean match(const BtpReq& other_value, boolean legacy = FALSE) const { return matchv(&other_value, legacy); }
inline void log_match(const BtpReq& match_value, boolean legacy = FALSE) const { log_matchv(&match_value, legacy); }
BtpReq valueof() const;
inline BtpReq_template& list_item(int list_index) const { return *(static_cast<BtpReq_template*>(get_list_item(list_index))); }
Btp__TypesAndValues::BtpPacket_template& msgOut();
const Btp__TypesAndValues::BtpPacket_template& msgOut() const;
Record_Template* create() const { return new BtpReq_template; }
const TTCN_Typedescriptor_t* get_descriptor() const;
const char* fld_name(int p_index) const;
};


/* Global variable declarations */

extern const TTCN_RAWdescriptor_t BtpInd_raw_;
extern const TTCN_JSONdescriptor_t BtpInd_json_;
extern const TTCN_Typedescriptor_t BtpInd_descr_;
extern const TTCN_RAWdescriptor_t BtpReq_raw_;
extern const TTCN_JSONdescriptor_t BtpReq_json_;
extern const TTCN_Typedescriptor_t BtpReq_descr_;
extern const TTCN_Typedescriptor_t& ItsBtpSystem_descr_;
extern BtpPort ItsBtpSystem_component_btpPort;
extern const TTCN_Typedescriptor_t& ItsBtp_descr_;
extern BtpPort ItsBtp_component_btpPort;
extern TTCN_Module module_object;

} /* end of namespace */

/* Test port header files */

#include "BtpPort.hh"

#endif
