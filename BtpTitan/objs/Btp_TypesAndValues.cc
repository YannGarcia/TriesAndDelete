// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for Yann Garcia (yann@Ubuntu64) on Tue Feb 28 11:22:01 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "Btp_TypesAndValues.hh"

namespace Btp__TypesAndValues {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x0d, 0x8f, 0xfe, 0x2f, 0xb1, 0xc6, 0x88, 0x5a, 0x95, 0x67, 0xdc, 0x14, 0x94, 0x8f, 0xe0, 0x77 };

/* Global variable definitions */

static INTEGER const_c__uInt16Max;
const INTEGER& c__uInt16Max = const_c__uInt16Max;
const TTCN_RAWdescriptor_t UInt16_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
const XERdescriptor_t       UInt16_xer_ = { {"UInt16>\n", "UInt16>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UInt16_descr_ = { "@Btp_TypesAndValues.UInt16", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &UInt16_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Oct2_raw_ = {16,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
const XERdescriptor_t       Oct2_xer_ = { {"Oct2>\n", "Oct2>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Oct2_descr_ = { "@Btp_TypesAndValues.Oct2", &OCTETSTRING_ber_, &Oct2_raw_, &OCTETSTRING_text_, &Oct2_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpHeader
const TTCN_JSONdescriptor_t BtpHeader_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpHeader_descr_ = { "@Btp_TypesAndValues.BtpHeader", NULL, &BtpHeader_raw_, NULL, NULL, &BtpHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpPortId_xer_ = { {"BtpPortId>\n", "BtpPortId>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpPortId_descr_ = { "@Btp_TypesAndValues.BtpPortId", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &BtpPortId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpAHeader_destinationPort_xer_ = { {"destinationPort>\n", "destinationPort>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpAHeader_destinationPort_descr_ = { "@Btp_TypesAndValues.BtpAHeader.destinationPort", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &BtpAHeader_destinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpAHeader_sourcePort_xer_ = { {"sourcePort>\n", "sourcePort>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpAHeader_sourcePort_descr_ = { "@Btp_TypesAndValues.BtpAHeader.sourcePort", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &BtpAHeader_sourcePort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpAHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpAHeader
const TTCN_JSONdescriptor_t BtpAHeader_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpAHeader_descr_ = { "@Btp_TypesAndValues.BtpAHeader", NULL, &BtpAHeader_raw_, NULL, NULL, &BtpAHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpBHeader_destinationPort_xer_ = { {"destinationPort>\n", "destinationPort>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpBHeader_destinationPort_descr_ = { "@Btp_TypesAndValues.BtpBHeader.destinationPort", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &BtpBHeader_destinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpPortInfo_xer_ = { {"BtpPortInfo>\n", "BtpPortInfo>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpPortInfo_descr_ = { "@Btp_TypesAndValues.BtpPortInfo", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &BtpPortInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpBHeader_destinationPortInfo_xer_ = { {"destinationPortInfo>\n", "destinationPortInfo>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpBHeader_destinationPortInfo_descr_ = { "@Btp_TypesAndValues.BtpBHeader.destinationPortInfo", &INTEGER_ber_, &UInt16_raw_, &INTEGER_text_, &BtpBHeader_destinationPortInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpBHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpBHeader
const TTCN_JSONdescriptor_t BtpBHeader_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpBHeader_descr_ = { "@Btp_TypesAndValues.BtpBHeader", NULL, &BtpBHeader_raw_, NULL, NULL, &BtpBHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpPacket_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpPacket
const TTCN_JSONdescriptor_t BtpPacket_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpPacket_descr_ = { "@Btp_TypesAndValues.BtpPacket", NULL, &BtpPacket_raw_, NULL, NULL, &BtpPacket_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpRawPayload_xer_ = { {"BtpRawPayload>\n", "BtpRawPayload>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpRawPayload_descr_ = { "@Btp_TypesAndValues.BtpRawPayload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &BtpRawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpPayload_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BtpPayload_rawPayload_descr_ = { "@Btp_TypesAndValues.BtpPayload.rawPayload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &BtpPayload_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpPayload
const TTCN_JSONdescriptor_t BtpPayload_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpPayload_descr_ = { "@Btp_TypesAndValues.BtpPayload", NULL, &BtpPayload_raw_, NULL, NULL, &BtpPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t DecodedBtpPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for DecodedBtpPayload
const TTCN_JSONdescriptor_t DecodedBtpPayload_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t DecodedBtpPayload_descr_ = { "@Btp_TypesAndValues.DecodedBtpPayload", NULL, &DecodedBtpPayload_raw_, NULL, NULL, &DecodedBtpPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       DecodedBtpPayload_raw__payload_xer_ = { {"raw_payload>\n", "raw_payload>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t DecodedBtpPayload_raw__payload_descr_ = { "@Btp_TypesAndValues.DecodedBtpPayload.raw_payload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &DecodedBtpPayload_raw__payload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for anytype
const TTCN_Typedescriptor_t anytype_descr_ = { "@Btp_TypesAndValues.anytype", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Frame_data__length_xer_ = { {"data_length>\n", "data_length>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Frame_data__length_descr_ = { "@Btp_TypesAndValues.Frame.data_length", &OCTETSTRING_ber_, &Oct2_raw_, &OCTETSTRING_text_, &Frame_data__length_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Frame_data__stream_xer_ = { {"data_stream>\n", "data_stream>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Frame_data__stream_descr_ = { "@Btp_TypesAndValues.Frame.data_stream", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &Frame_data__stream_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Frame_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for Frame
const TTCN_JSONdescriptor_t Frame_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t Frame_descr_ = { "@Btp_TypesAndValues.Frame", NULL, &Frame_raw_, NULL, NULL, &Frame_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("Btp_TypesAndValues", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_2);

/* Member functions of C++ classes */

void BtpHeader::copy_value(const BtpHeader& other_value)
{
switch (other_value.union_selection) {
case ALT_btpAHeader:
field_btpAHeader = new BtpAHeader(*other_value.field_btpAHeader);
break;
case ALT_btpBHeader:
field_btpBHeader = new BtpBHeader(*other_value.field_btpBHeader);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Btp_TypesAndValues.BtpHeader.");
}
union_selection = other_value.union_selection;
err_descr = other_value.err_descr;
}

BtpHeader::BtpHeader(): err_descr(NULL)
{
union_selection = UNBOUND_VALUE;
}

BtpHeader::BtpHeader(const BtpHeader& other_value)
: Base_Type(){
copy_value(other_value);
}

BtpHeader::~BtpHeader()
{
clean_up();
}

BtpHeader& BtpHeader::operator=(const BtpHeader& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean BtpHeader::operator==(const BtpHeader& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Btp_TypesAndValues.BtpHeader.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Btp_TypesAndValues.BtpHeader.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_btpAHeader:
return *field_btpAHeader == *other_value.field_btpAHeader;
case ALT_btpBHeader:
return *field_btpBHeader == *other_value.field_btpBHeader;
default:
return FALSE;
}
}

BtpAHeader& BtpHeader::btpAHeader()
{
if (union_selection != ALT_btpAHeader) {
clean_up();
field_btpAHeader = new BtpAHeader;
union_selection = ALT_btpAHeader;
}
return *field_btpAHeader;
}

const BtpAHeader& BtpHeader::btpAHeader() const
{
if (union_selection != ALT_btpAHeader) TTCN_error("Using non-selected field btpAHeader in a value of union type @Btp_TypesAndValues.BtpHeader.");
return *field_btpAHeader;
}

BtpBHeader& BtpHeader::btpBHeader()
{
if (union_selection != ALT_btpBHeader) {
clean_up();
field_btpBHeader = new BtpBHeader;
union_selection = ALT_btpBHeader;
}
return *field_btpBHeader;
}

const BtpBHeader& BtpHeader::btpBHeader() const
{
if (union_selection != ALT_btpBHeader) TTCN_error("Using non-selected field btpBHeader in a value of union type @Btp_TypesAndValues.BtpHeader.");
return *field_btpBHeader;
}

boolean BtpHeader::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Btp_TypesAndValues.BtpHeader.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Btp_TypesAndValues.BtpHeader.");
return union_selection == checked_selection;
}

boolean BtpHeader::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean BtpHeader::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_btpAHeader: return field_btpAHeader->is_value();
case ALT_btpBHeader: return field_btpBHeader->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void BtpHeader::clean_up()
{
switch (union_selection) {
case ALT_btpAHeader:
  delete field_btpAHeader;
  break;
case ALT_btpBHeader:
  delete field_btpBHeader;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

boolean BtpHeader::is_equal(const Base_Type* other_value) const { return *this == *(static_cast<const BtpHeader*>(other_value)); }
void BtpHeader::set_value(const Base_Type* other_value) { *this = *(static_cast<const BtpHeader*>(other_value)); }
Base_Type* BtpHeader::clone() const { return new BtpHeader(*this); }
const TTCN_Typedescriptor_t* BtpHeader::get_descriptor() const { return &BtpHeader_descr_; }
void BtpHeader::log() const
{
switch (union_selection) {
case ALT_btpAHeader:
TTCN_Logger::log_event_str("{ btpAHeader := ");
field_btpAHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_btpBHeader:
TTCN_Logger::log_event_str("{ btpBHeader := ");
field_btpBHeader->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
if (err_descr) err_descr->log();
}

void BtpHeader::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@Btp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      btpAHeader().set_param(param);
      return;
    } else if (strcmp("btpBHeader", param_field) == 0) {
      btpBHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@Btp_TypesAndValues.BtpHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    m_p = param.get_referenced_param();
  }
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "btpAHeader")) {
    btpAHeader().set_param(*mp_last);
    if (!btpAHeader().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "btpBHeader")) {
    btpBHeader().set_param(*mp_last);
    if (!btpBHeader().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Btp_TypesAndValues.BtpHeader.", mp_last->get_id()->get_name());
}

Module_Param* BtpHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@Btp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      return btpAHeader().get_param(param_name);
    } else if (strcmp("btpBHeader", param_field) == 0) {
      return btpBHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `BtpHeader'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_btpAHeader:
    mp_field = field_btpAHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpAHeader")));
    break;
  case ALT_btpBHeader:
    mp_field = field_btpBHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpBHeader")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* m_p = new Module_Param_Assignment_List();
  m_p->add_elem(mp_field);
  return m_p;
}

void BtpHeader::set_implicit_omit()
{
switch (union_selection) {
case ALT_btpAHeader:
field_btpAHeader->set_implicit_omit(); break;
case ALT_btpBHeader:
field_btpBHeader->set_implicit_omit(); break;
default: break;
}
}

void BtpHeader::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_btpAHeader:
field_btpAHeader->encode_text(text_buf);
break;
case ALT_btpBHeader:
field_btpBHeader->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Btp_TypesAndValues.BtpHeader.");
}
}

void BtpHeader::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_btpAHeader:
btpAHeader().decode_text(text_buf);
break;
case ALT_btpBHeader:
btpBHeader().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Btp_TypesAndValues.BtpHeader.");
}
}

void BtpHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BtpHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BtpHeader::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = btpAHeader().RAW_decode(BtpAHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = btpBHeader().RAW_decode(BtpBHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpAHeader().RAW_decode(BtpAHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpBHeader().RAW_decode(BtpBHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int BtpHeader::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  if (err_descr) return RAW_encode_negtest(err_descr, p_td, myleaf);
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_btpAHeader:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, BtpAHeader_descr_.raw);
    encoded_length = field_btpAHeader->RAW_encode(BtpAHeader_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &BtpAHeader_descr_;
    break;
  case ALT_btpBHeader:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, BtpBHeader_descr_.raw);
    encoded_length = field_btpBHeader->RAW_encode(BtpBHeader_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &BtpBHeader_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int BtpHeader::RAW_encode_negtest(const Erroneous_descriptor_t *p_err_descr, const TTCN_Typedescriptor_t& /*p_td*/, RAW_enc_tree& myleaf) const
{
  const Erroneous_values_t *err_vals = NULL;
  const Erroneous_descriptor_t *emb_descr = NULL;
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_btpAHeader: {
    err_vals = p_err_descr->get_field_err_values(0);
    emb_descr = p_err_descr->get_field_emb_descr(0);
    if (err_vals && err_vals->value) {
      if (err_vals->value->raw) {
        myleaf.body.node.nodes[0] =
          new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, err_vals->value->errval->get_descriptor()->raw);
        encoded_length = err_vals->value->errval->RAW_encode_negtest_raw(*myleaf.body.node.nodes[0]);
        myleaf.body.node.nodes[0]->coding_descr = err_vals->value->errval->get_descriptor();
      } else {
        if (err_vals->value->errval) {
          if (err_vals->value->type_descr == NULL)
            TTCN_error("internal error: erroneous value typedescriptor missing");
          myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, err_vals->value->type_descr->raw);
          encoded_length = err_vals->value->errval->RAW_encode(*err_vals->value->type_descr, *myleaf.body.node.nodes[0]);
          myleaf.body.node.nodes[0]->coding_descr = err_vals->value->type_descr;
        }
      }
    } else {
      myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, BtpAHeader_descr_.raw);
      if (emb_descr) {
        encoded_length = field_btpAHeader->RAW_encode_negtest(emb_descr, BtpAHeader_descr_, *myleaf.body.node.nodes[0]);
      } else encoded_length = field_btpAHeader->RAW_encode(BtpAHeader_descr_, *myleaf.body.node.nodes[0]);
      myleaf.body.node.nodes[0]->coding_descr = &BtpAHeader_descr_;
    }
    break; }
  case ALT_btpBHeader: {
    err_vals = p_err_descr->get_field_err_values(1);
    emb_descr = p_err_descr->get_field_emb_descr(1);
    if (err_vals && err_vals->value) {
      if (err_vals->value->raw) {
        myleaf.body.node.nodes[1] =
          new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, err_vals->value->errval->get_descriptor()->raw);
        encoded_length = err_vals->value->errval->RAW_encode_negtest_raw(*myleaf.body.node.nodes[1]);
        myleaf.body.node.nodes[1]->coding_descr = err_vals->value->errval->get_descriptor();
      } else {
        if (err_vals->value->errval) {
          if (err_vals->value->type_descr == NULL)
            TTCN_error("internal error: erroneous value typedescriptor missing");
          myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, err_vals->value->type_descr->raw);
          encoded_length = err_vals->value->errval->RAW_encode(*err_vals->value->type_descr, *myleaf.body.node.nodes[1]);
          myleaf.body.node.nodes[1]->coding_descr = err_vals->value->type_descr;
        }
      }
    } else {
      myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, BtpBHeader_descr_.raw);
      if (emb_descr) {
        encoded_length = field_btpBHeader->RAW_encode_negtest(emb_descr, BtpBHeader_descr_, *myleaf.body.node.nodes[1]);
      } else encoded_length = field_btpBHeader->RAW_encode(BtpBHeader_descr_, *myleaf.body.node.nodes[1]);
      myleaf.body.node.nodes[1]->coding_descr = &BtpBHeader_descr_;
    }
    break; }
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int BtpHeader::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (err_descr) return JSON_encode_negtest(err_descr, p_td, p_tok);
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_btpAHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpAHeader");
    enc_len += field_btpAHeader->JSON_encode(BtpAHeader_descr_, p_tok);
    break;
  case ALT_btpBHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpBHeader");
    enc_len += field_btpBHeader->JSON_encode(BtpBHeader_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @Btp_TypesAndValues.BtpHeader.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpHeader::JSON_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  const Erroneous_values_t* err_vals = NULL;
  const Erroneous_descriptor_t* emb_descr = NULL;
  switch(union_selection) {
  case ALT_btpAHeader:
    err_vals = p_err_descr->get_field_err_values(0);
    emb_descr = p_err_descr->get_field_emb_descr(0);
    if (NULL != err_vals && NULL != err_vals->value) {
      if (NULL != err_vals->value->errval) {
        if(err_vals->value->raw){
          enc_len += err_vals->value->errval->JSON_encode_negtest_raw(p_tok);
        } else {
          if (NULL == err_vals->value->type_descr) {
            TTCN_error("internal error: erroneous value typedescriptor missing");
          }
          enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpAHeader");
          enc_len += err_vals->value->errval->JSON_encode(*err_vals->value->type_descr, p_tok);
        }
      }
    } else {
      enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpAHeader");
      if (NULL != emb_descr) {
        enc_len += field_btpAHeader->JSON_encode_negtest(emb_descr, BtpAHeader_descr_, p_tok);
      } else {
        enc_len += field_btpAHeader->JSON_encode(BtpAHeader_descr_, p_tok);
      }
    }
    break;
  case ALT_btpBHeader:
    err_vals = p_err_descr->get_field_err_values(1);
    emb_descr = p_err_descr->get_field_emb_descr(1);
    if (NULL != err_vals && NULL != err_vals->value) {
      if (NULL != err_vals->value->errval) {
        if(err_vals->value->raw){
          enc_len += err_vals->value->errval->JSON_encode_negtest_raw(p_tok);
        } else {
          if (NULL == err_vals->value->type_descr) {
            TTCN_error("internal error: erroneous value typedescriptor missing");
          }
          enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpBHeader");
          enc_len += err_vals->value->errval->JSON_encode(*err_vals->value->type_descr, p_tok);
        }
      }
    } else {
      enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpBHeader");
      if (NULL != emb_descr) {
        enc_len += field_btpBHeader->JSON_encode_negtest(emb_descr, BtpBHeader_descr_, p_tok);
      } else {
        enc_len += field_btpBHeader->JSON_encode(BtpBHeader_descr_, p_tok);
      }
    }
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @Btp_TypesAndValues.BtpHeader.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  size_t dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;
  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "btpAHeader", name_len)) {
      int ret_val = btpAHeader().JSON_decode(BtpAHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 10, "btpAHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += (size_t)ret_val;
      }
    } else if (0 == strncmp(fld_name, "btpBHeader", name_len)) {
      int ret_val = btpBHeader().JSON_decode(BtpBHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 10, "btpBHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += (size_t)ret_val;
      }
    } else {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, (int)name_len, fld_name);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return (int)dec_len;
}

void BtpHeader_template::copy_value(const BtpHeader& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader = new BtpAHeader_template(other_value.btpAHeader());
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader = new BtpBHeader_template(other_value.btpBHeader());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Btp_TypesAndValues.BtpHeader.");
}
set_selection(SPECIFIC_VALUE);
err_descr = other_value.get_err_descr();
}

void BtpHeader_template::copy_template(const BtpHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader = new BtpAHeader_template(*other_value.single_value.field_btpAHeader);
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader = new BtpBHeader_template(*other_value.single_value.field_btpBHeader);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Btp_TypesAndValues.BtpHeader.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BtpHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Btp_TypesAndValues.BtpHeader.");
}
set_selection(other_value);
err_descr = other_value.err_descr;
}

BtpHeader_template::BtpHeader_template(): err_descr(NULL)
{
}

BtpHeader_template::BtpHeader_template(template_sel other_value)
 : Base_Template(other_value), err_descr(NULL)
{
check_single_selection(other_value);
}

BtpHeader_template::BtpHeader_template(const BtpHeader& other_value)
{
copy_value(other_value);
}

BtpHeader_template::BtpHeader_template(const OPTIONAL<BtpHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
err_descr = NULL;
break;
default:
TTCN_error("Creating a template of union type @Btp_TypesAndValues.BtpHeader from an unbound optional field.");
}
}

BtpHeader_template::BtpHeader_template(const BtpHeader_template& other_value)
: Base_Template(){
copy_template(other_value);
}

BtpHeader_template::~BtpHeader_template()
{
clean_up();
}

void BtpHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
delete single_value.field_btpAHeader;
break;
case BtpHeader::ALT_btpBHeader:
delete single_value.field_btpBHeader;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BtpHeader_template& BtpHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
err_descr = NULL;
return *this;
}

BtpHeader_template& BtpHeader_template::operator=(const BtpHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BtpHeader_template& BtpHeader_template::operator=(const OPTIONAL<BtpHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
err_descr = NULL;
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Btp_TypesAndValues.BtpHeader.");
}
return *this;
}

BtpHeader_template& BtpHeader_template::operator=(const BtpHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BtpHeader_template::match(const BtpHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
BtpHeader::union_selection_type value_selection = other_value.get_selection();
if (value_selection == BtpHeader::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case BtpHeader::ALT_btpAHeader:
return single_value.field_btpAHeader->match(other_value.btpAHeader(), legacy);
case BtpHeader::ALT_btpBHeader:
return single_value.field_btpBHeader->match(other_value.btpBHeader(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Btp_TypesAndValues.BtpHeader.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Btp_TypesAndValues.BtpHeader.");
}
return FALSE;
}

boolean BtpHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
return single_value.field_btpAHeader->is_value();
case BtpHeader::ALT_btpBHeader:
return single_value.field_btpBHeader->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Btp_TypesAndValues.BtpHeader.");
}
}

BtpHeader BtpHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Btp_TypesAndValues.BtpHeader.");
BtpHeader ret_val;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
ret_val.btpAHeader() = single_value.field_btpAHeader->valueof();
break;
case BtpHeader::ALT_btpBHeader:
ret_val.btpBHeader() = single_value.field_btpBHeader->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Btp_TypesAndValues.BtpHeader.");
}
ret_val.set_err_descr(err_descr);
return ret_val;
}

BtpHeader_template& BtpHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Btp_TypesAndValues.BtpHeader.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Btp_TypesAndValues.BtpHeader.");
return value_list.list_value[list_index];
}
void BtpHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Btp_TypesAndValues.BtpHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BtpHeader_template[list_length];
}

BtpAHeader_template& BtpHeader_template::btpAHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != BtpHeader::ALT_btpAHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpAHeader = new BtpAHeader_template(ANY_VALUE);
else single_value.field_btpAHeader = new BtpAHeader_template;
single_value.union_selection = BtpHeader::ALT_btpAHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpAHeader;
}

const BtpAHeader_template& BtpHeader_template::btpAHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpAHeader in a non-specific template of union type @Btp_TypesAndValues.BtpHeader.");
if (single_value.union_selection != BtpHeader::ALT_btpAHeader) TTCN_error("Accessing non-selected field btpAHeader in a template of union type @Btp_TypesAndValues.BtpHeader.");
return *single_value.field_btpAHeader;
}

BtpBHeader_template& BtpHeader_template::btpBHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != BtpHeader::ALT_btpBHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpBHeader = new BtpBHeader_template(ANY_VALUE);
else single_value.field_btpBHeader = new BtpBHeader_template;
single_value.union_selection = BtpHeader::ALT_btpBHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpBHeader;
}

const BtpBHeader_template& BtpHeader_template::btpBHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpBHeader in a non-specific template of union type @Btp_TypesAndValues.BtpHeader.");
if (single_value.union_selection != BtpHeader::ALT_btpBHeader) TTCN_error("Accessing non-selected field btpBHeader in a template of union type @Btp_TypesAndValues.BtpHeader.");
return *single_value.field_btpBHeader;
}

boolean BtpHeader_template::ischosen(BtpHeader::union_selection_type checked_selection) const
{
if (checked_selection == BtpHeader::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Btp_TypesAndValues.BtpHeader.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == BtpHeader::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Btp_TypesAndValues.BtpHeader.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Btp_TypesAndValues.BtpHeader containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Btp_TypesAndValues.BtpHeader, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Btp_TypesAndValues.BtpHeader");
}
return FALSE;
}

void BtpHeader_template::valueofv(Base_Type* value) const { *(static_cast<BtpHeader*>(value)) = valueof(); }
void BtpHeader_template::set_value(template_sel other_value) { *this = other_value; }
void BtpHeader_template::copy_value(const Base_Type* other_value) { *this = *(static_cast<const BtpHeader*>(other_value)); }
Base_Template* BtpHeader_template::clone() const { return new BtpHeader_template(*this); }
const TTCN_Typedescriptor_t* BtpHeader_template::get_descriptor() const { return &BtpHeader_descr_; }
boolean BtpHeader_template::matchv(const Base_Type* other_value, boolean legacy) const { return match(*(static_cast<const BtpHeader*>(other_value)), legacy); }
void BtpHeader_template::log_matchv(const Base_Type* match_value, boolean legacy) const  { log_match(*(static_cast<const BtpHeader*>(match_value)), legacy); }
void BtpHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
TTCN_Logger::log_event_str("{ btpAHeader := ");
single_value.field_btpAHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case BtpHeader::ALT_btpBHeader:
TTCN_Logger::log_event_str("{ btpBHeader := ");
single_value.field_btpBHeader->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
if (err_descr) err_descr->log();
}

void BtpHeader_template::log_match(const BtpHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpAHeader");
single_value.field_btpAHeader->log_match(match_value.btpAHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpAHeader := ");
single_value.field_btpAHeader->log_match(match_value.btpAHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case BtpHeader::ALT_btpBHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpBHeader");
single_value.field_btpBHeader->log_match(match_value.btpBHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpBHeader := ");
single_value.field_btpBHeader->log_match(match_value.btpBHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BtpHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader->encode_text(text_buf);
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Btp_TypesAndValues.BtpHeader.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Btp_TypesAndValues.BtpHeader.");
}
}

void BtpHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = BtpHeader::UNBOUND_VALUE;
BtpHeader::union_selection_type new_selection = (BtpHeader::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader = new BtpAHeader_template;
single_value.field_btpAHeader->decode_text(text_buf);
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader = new BtpBHeader_template;
single_value.field_btpBHeader->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Btp_TypesAndValues.BtpHeader.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BtpHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Btp_TypesAndValues.BtpHeader.");
}
}

boolean BtpHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BtpHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void BtpHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Btp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      btpAHeader().set_param(param);
      return;
    } else if (strcmp("btpBHeader", param_field) == 0) {
      btpBHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Btp_TypesAndValues.BtpHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    m_p = param.get_referenced_param();
  }
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BtpHeader_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Btp_TypesAndValues.BtpHeader");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "btpAHeader")) {
      btpAHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "btpBHeader")) {
      btpBHeader().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Btp_TypesAndValues.BtpHeader.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Btp_TypesAndValues.BtpHeader");
  }
  is_ifpresent = param.get_ifpresent() || m_p->get_ifpresent();
}

Module_Param* BtpHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@Btp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      return btpAHeader().get_param(param_name);
    } else if (strcmp("btpBHeader", param_field) == 0) {
      return btpBHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `BtpHeader'", param_field);
  }
  Module_Param* m_p = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    m_p = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    m_p = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    m_p = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    m_p = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case BtpHeader::ALT_btpAHeader:
      mp_field = single_value.field_btpAHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpAHeader")));
      break;
    case BtpHeader::ALT_btpBHeader:
      mp_field = single_value.field_btpBHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpBHeader")));
      break;
    default:
      break;
    }
    m_p = new Module_Param_Assignment_List();
    m_p->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      m_p = new Module_Param_List_Template();
    }
    else {
      m_p = new Module_Param_ComplementList_Template();
    }
    for (size_t i_i = 0; i_i < value_list.n_values; ++i_i) {
      m_p->add_elem(value_list.list_value[i_i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    m_p->set_ifpresent();
  }
  return m_p;
}

void BtpHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader->check_restriction(t_res, t_name ? t_name : "@Btp_TypesAndValues.BtpHeader");
return;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader->check_restriction(t_res, t_name ? t_name : "@Btp_TypesAndValues.BtpHeader");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Btp_TypesAndValues.BtpHeader.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Btp_TypesAndValues.BtpHeader");
}

void BtpAHeader::init_vec() { fld_vec[0]=&field_destinationPort; fld_vec[1]=&field_sourcePort;  }

BtpAHeader::BtpAHeader() : Record_Type() { init_vec(); }

BtpAHeader::BtpAHeader(const BtpAHeader& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_destinationPort.is_bound() )
  field_destinationPort = other_value.field_destinationPort;
if (other_value.field_sourcePort.is_bound() )
  field_sourcePort = other_value.field_sourcePort;
init_vec();
}

BtpAHeader::BtpAHeader(const INTEGER& par_destinationPort,
    const INTEGER& par_sourcePort) : field_destinationPort(par_destinationPort),
    field_sourcePort(par_sourcePort)
{
init_vec();
}

const TTCN_Typedescriptor_t* BtpAHeader::get_descriptor() const { return &BtpAHeader_descr_; }
const TTCN_Typedescriptor_t* BtpAHeader::fld_descriptors[] = { &BtpPortId_descr_, &BtpPortId_descr_ };
const TTCN_Typedescriptor_t* BtpAHeader::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* BtpAHeader::fld_names[] = { "destinationPort", "sourcePort" };
const char* BtpAHeader::fld_name(int p_index) const { return fld_names[p_index]; }

void BtpAHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 2;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new INTEGER_template(ANY_VALUE) : new INTEGER_template;
single_value.value_elements[1] = was_any ? new INTEGER_template(ANY_VALUE) : new INTEGER_template;
}
}

BtpAHeader_template& BtpAHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpAHeader_template& BtpAHeader_template::operator=(const BtpAHeader& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

BtpAHeader_template& BtpAHeader_template::operator=(const OPTIONAL<BtpAHeader>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

BtpAHeader_template& BtpAHeader_template::operator=(const BtpAHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

BtpAHeader BtpAHeader_template::valueof() const
{
BtpAHeader ret_val;
valueofv(&ret_val);
return ret_val;
}

INTEGER_template& BtpAHeader_template::destinationPort() { return *(static_cast<INTEGER_template*>(get_at(0))); }
const INTEGER_template& BtpAHeader_template::destinationPort() const { return *(static_cast<const INTEGER_template*>(get_at(0))); }
INTEGER_template& BtpAHeader_template::sourcePort() { return *(static_cast<INTEGER_template*>(get_at(1))); }
const INTEGER_template& BtpAHeader_template::sourcePort() const { return *(static_cast<const INTEGER_template*>(get_at(1))); }
const TTCN_Typedescriptor_t* BtpAHeader_template::get_descriptor() const { return &BtpAHeader_descr_; }
const char* BtpAHeader_template::fld_name(int p_index) const { return BtpAHeader::fld_names[p_index]; }
void BtpBHeader::init_vec() { fld_vec[0]=&field_destinationPort; fld_vec[1]=&field_destinationPortInfo;  }

BtpBHeader::BtpBHeader() : Record_Type() { init_vec(); }

BtpBHeader::BtpBHeader(const BtpBHeader& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_destinationPort.is_bound() )
  field_destinationPort = other_value.field_destinationPort;
if (other_value.field_destinationPortInfo.is_bound() )
  field_destinationPortInfo = other_value.field_destinationPortInfo;
init_vec();
}

BtpBHeader::BtpBHeader(const INTEGER& par_destinationPort,
    const INTEGER& par_destinationPortInfo) : field_destinationPort(par_destinationPort),
    field_destinationPortInfo(par_destinationPortInfo)
{
init_vec();
}

const TTCN_Typedescriptor_t* BtpBHeader::get_descriptor() const { return &BtpBHeader_descr_; }
const TTCN_Typedescriptor_t* BtpBHeader::fld_descriptors[] = { &BtpPortId_descr_, &BtpPortInfo_descr_ };
const TTCN_Typedescriptor_t* BtpBHeader::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* BtpBHeader::fld_names[] = { "destinationPort", "destinationPortInfo" };
const char* BtpBHeader::fld_name(int p_index) const { return fld_names[p_index]; }

void BtpBHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 2;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new INTEGER_template(ANY_VALUE) : new INTEGER_template;
single_value.value_elements[1] = was_any ? new INTEGER_template(ANY_VALUE) : new INTEGER_template;
}
}

BtpBHeader_template& BtpBHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpBHeader_template& BtpBHeader_template::operator=(const BtpBHeader& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

BtpBHeader_template& BtpBHeader_template::operator=(const OPTIONAL<BtpBHeader>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

BtpBHeader_template& BtpBHeader_template::operator=(const BtpBHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

BtpBHeader BtpBHeader_template::valueof() const
{
BtpBHeader ret_val;
valueofv(&ret_val);
return ret_val;
}

INTEGER_template& BtpBHeader_template::destinationPort() { return *(static_cast<INTEGER_template*>(get_at(0))); }
const INTEGER_template& BtpBHeader_template::destinationPort() const { return *(static_cast<const INTEGER_template*>(get_at(0))); }
INTEGER_template& BtpBHeader_template::destinationPortInfo() { return *(static_cast<INTEGER_template*>(get_at(1))); }
const INTEGER_template& BtpBHeader_template::destinationPortInfo() const { return *(static_cast<const INTEGER_template*>(get_at(1))); }
const TTCN_Typedescriptor_t* BtpBHeader_template::get_descriptor() const { return &BtpBHeader_descr_; }
const char* BtpBHeader_template::fld_name(int p_index) const { return BtpBHeader::fld_names[p_index]; }
void BtpPacket::init_vec() { fld_vec[0]=&field_header; fld_vec[1]=&field_payload;  }

BtpPacket::BtpPacket() : Record_Type() { init_vec(); }

BtpPacket::BtpPacket(const BtpPacket& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_header.is_bound() )
  field_header = other_value.field_header;
if (other_value.field_payload.is_bound() )
  field_payload = other_value.field_payload;
init_vec();
}

BtpPacket::BtpPacket(const BtpHeader& par_header,
    const OPTIONAL<BtpPayload>& par_payload) : field_header(par_header),
    field_payload(par_payload)
{
init_vec();
}

const TTCN_Typedescriptor_t* BtpPacket::get_descriptor() const { return &BtpPacket_descr_; }
const TTCN_Typedescriptor_t* BtpPacket::fld_descriptors[] = { &BtpHeader_descr_, &BtpPayload_descr_ };
const TTCN_Typedescriptor_t* BtpPacket::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* BtpPacket::fld_names[] = { "header", "payload" };
const char* BtpPacket::fld_name(int p_index) const { return fld_names[p_index]; }

const int BtpPacket::optional_indexes[] = { 1, -1 };
const int* BtpPacket::get_optional_indexes() const { return optional_indexes; }

void BtpPacket_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 2;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new BtpHeader_template(ANY_VALUE) : new BtpHeader_template;
single_value.value_elements[1] = was_any ? new BtpPayload_template(ANY_OR_OMIT) : new BtpPayload_template;
}
}

BtpPacket_template& BtpPacket_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpPacket_template& BtpPacket_template::operator=(const BtpPacket& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

BtpPacket_template& BtpPacket_template::operator=(const OPTIONAL<BtpPacket>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

BtpPacket_template& BtpPacket_template::operator=(const BtpPacket_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

BtpPacket BtpPacket_template::valueof() const
{
BtpPacket ret_val;
valueofv(&ret_val);
return ret_val;
}

BtpHeader_template& BtpPacket_template::header() { return *(static_cast<BtpHeader_template*>(get_at(0))); }
const BtpHeader_template& BtpPacket_template::header() const { return *(static_cast<const BtpHeader_template*>(get_at(0))); }
BtpPayload_template& BtpPacket_template::payload() { return *(static_cast<BtpPayload_template*>(get_at(1))); }
const BtpPayload_template& BtpPacket_template::payload() const { return *(static_cast<const BtpPayload_template*>(get_at(1))); }
const TTCN_Typedescriptor_t* BtpPacket_template::get_descriptor() const { return &BtpPacket_descr_; }
const char* BtpPacket_template::fld_name(int p_index) const { return BtpPacket::fld_names[p_index]; }
void BtpPayload::init_vec() { fld_vec[0]=&field_decodedPayload; fld_vec[1]=&field_rawPayload;  }

BtpPayload::BtpPayload() : Record_Type() { init_vec(); }

BtpPayload::BtpPayload(const BtpPayload& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_decodedPayload.is_bound() )
  field_decodedPayload = other_value.field_decodedPayload;
if (other_value.field_rawPayload.is_bound() )
  field_rawPayload = other_value.field_rawPayload;
init_vec();
}

BtpPayload::BtpPayload(const OPTIONAL<DecodedBtpPayload>& par_decodedPayload,
    const OCTETSTRING& par_rawPayload) : field_decodedPayload(par_decodedPayload),
    field_rawPayload(par_rawPayload)
{
init_vec();
}

const TTCN_Typedescriptor_t* BtpPayload::get_descriptor() const { return &BtpPayload_descr_; }
const TTCN_Typedescriptor_t* BtpPayload::fld_descriptors[] = { &DecodedBtpPayload_descr_, &BtpRawPayload_descr_ };
const TTCN_Typedescriptor_t* BtpPayload::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* BtpPayload::fld_names[] = { "decodedPayload", "rawPayload" };
const char* BtpPayload::fld_name(int p_index) const { return fld_names[p_index]; }

const int BtpPayload::optional_indexes[] = { 0, -1 };
const int* BtpPayload::get_optional_indexes() const { return optional_indexes; }

void BtpPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 2;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new DecodedBtpPayload_template(ANY_OR_OMIT) : new DecodedBtpPayload_template;
single_value.value_elements[1] = was_any ? new OCTETSTRING_template(ANY_VALUE) : new OCTETSTRING_template;
}
}

BtpPayload_template& BtpPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpPayload_template& BtpPayload_template::operator=(const BtpPayload& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

BtpPayload_template& BtpPayload_template::operator=(const OPTIONAL<BtpPayload>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

BtpPayload_template& BtpPayload_template::operator=(const BtpPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

BtpPayload BtpPayload_template::valueof() const
{
BtpPayload ret_val;
valueofv(&ret_val);
return ret_val;
}

DecodedBtpPayload_template& BtpPayload_template::decodedPayload() { return *(static_cast<DecodedBtpPayload_template*>(get_at(0))); }
const DecodedBtpPayload_template& BtpPayload_template::decodedPayload() const { return *(static_cast<const DecodedBtpPayload_template*>(get_at(0))); }
OCTETSTRING_template& BtpPayload_template::rawPayload() { return *(static_cast<OCTETSTRING_template*>(get_at(1))); }
const OCTETSTRING_template& BtpPayload_template::rawPayload() const { return *(static_cast<const OCTETSTRING_template*>(get_at(1))); }
const TTCN_Typedescriptor_t* BtpPayload_template::get_descriptor() const { return &BtpPayload_descr_; }
const char* BtpPayload_template::fld_name(int p_index) const { return BtpPayload::fld_names[p_index]; }
void DecodedBtpPayload::copy_value(const DecodedBtpPayload& other_value)
{
switch (other_value.union_selection) {
case ALT_raw__payload:
field_raw__payload = new OCTETSTRING(*other_value.field_raw__payload);
break;
case ALT_payload:
field_payload = new anytype(*other_value.field_payload);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Btp_TypesAndValues.DecodedBtpPayload.");
}
union_selection = other_value.union_selection;
err_descr = other_value.err_descr;
}

DecodedBtpPayload::DecodedBtpPayload(): err_descr(NULL)
{
union_selection = UNBOUND_VALUE;
}

DecodedBtpPayload::DecodedBtpPayload(const DecodedBtpPayload& other_value)
: Base_Type(){
copy_value(other_value);
}

DecodedBtpPayload::~DecodedBtpPayload()
{
clean_up();
}

DecodedBtpPayload& DecodedBtpPayload::operator=(const DecodedBtpPayload& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean DecodedBtpPayload::operator==(const DecodedBtpPayload& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Btp_TypesAndValues.DecodedBtpPayload.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Btp_TypesAndValues.DecodedBtpPayload.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_raw__payload:
return *field_raw__payload == *other_value.field_raw__payload;
case ALT_payload:
return *field_payload == *other_value.field_payload;
default:
return FALSE;
}
}

OCTETSTRING& DecodedBtpPayload::raw__payload()
{
if (union_selection != ALT_raw__payload) {
clean_up();
field_raw__payload = new OCTETSTRING;
union_selection = ALT_raw__payload;
}
return *field_raw__payload;
}

const OCTETSTRING& DecodedBtpPayload::raw__payload() const
{
if (union_selection != ALT_raw__payload) TTCN_error("Using non-selected field raw_payload in a value of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return *field_raw__payload;
}

anytype& DecodedBtpPayload::payload()
{
if (union_selection != ALT_payload) {
clean_up();
field_payload = new anytype;
union_selection = ALT_payload;
}
return *field_payload;
}

const anytype& DecodedBtpPayload::payload() const
{
if (union_selection != ALT_payload) TTCN_error("Using non-selected field payload in a value of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return *field_payload;
}

boolean DecodedBtpPayload::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Btp_TypesAndValues.DecodedBtpPayload.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return union_selection == checked_selection;
}

boolean DecodedBtpPayload::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean DecodedBtpPayload::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_raw__payload: return field_raw__payload->is_value();
case ALT_payload: return field_payload->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void DecodedBtpPayload::clean_up()
{
switch (union_selection) {
case ALT_raw__payload:
  delete field_raw__payload;
  break;
case ALT_payload:
  delete field_payload;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

boolean DecodedBtpPayload::is_equal(const Base_Type* other_value) const { return *this == *(static_cast<const DecodedBtpPayload*>(other_value)); }
void DecodedBtpPayload::set_value(const Base_Type* other_value) { *this = *(static_cast<const DecodedBtpPayload*>(other_value)); }
Base_Type* DecodedBtpPayload::clone() const { return new DecodedBtpPayload(*this); }
const TTCN_Typedescriptor_t* DecodedBtpPayload::get_descriptor() const { return &DecodedBtpPayload_descr_; }
void DecodedBtpPayload::log() const
{
switch (union_selection) {
case ALT_raw__payload:
TTCN_Logger::log_event_str("{ raw_payload := ");
field_raw__payload->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_payload:
TTCN_Logger::log_event_str("{ payload := ");
field_payload->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
if (err_descr) err_descr->log();
}

void DecodedBtpPayload::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@Btp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("raw_payload", param_field) == 0) {
      raw__payload().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@Btp_TypesAndValues.DecodedBtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    m_p = param.get_referenced_param();
  }
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "raw_payload")) {
    raw__payload().set_param(*mp_last);
    if (!raw__payload().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "payload")) {
    payload().set_param(*mp_last);
    if (!payload().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Btp_TypesAndValues.DecodedBtpPayload.", mp_last->get_id()->get_name());
}

Module_Param* DecodedBtpPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@Btp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("raw_payload", param_field) == 0) {
      return raw__payload().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `DecodedBtpPayload'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_raw__payload:
    mp_field = field_raw__payload->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("raw_payload")));
    break;
  case ALT_payload:
    mp_field = field_payload->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("payload")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* m_p = new Module_Param_Assignment_List();
  m_p->add_elem(mp_field);
  return m_p;
}

void DecodedBtpPayload::set_implicit_omit()
{
switch (union_selection) {
case ALT_raw__payload:
field_raw__payload->set_implicit_omit(); break;
case ALT_payload:
field_payload->set_implicit_omit(); break;
default: break;
}
}

void DecodedBtpPayload::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_raw__payload:
field_raw__payload->encode_text(text_buf);
break;
case ALT_payload:
field_payload->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
}

void DecodedBtpPayload::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_raw__payload:
raw__payload().decode_text(text_buf);
break;
case ALT_payload:
payload().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Btp_TypesAndValues.DecodedBtpPayload.");
}
}

void DecodedBtpPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DecodedBtpPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, XER_NONE, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, FALSE)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int DecodedBtpPayload::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = raw__payload().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = payload().RAW_decode(anytype_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = raw__payload().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = payload().RAW_decode(anytype_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int DecodedBtpPayload::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  if (err_descr) return RAW_encode_negtest(err_descr, p_td, myleaf);
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_raw__payload:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, OCTETSTRING_descr_.raw);
    encoded_length = field_raw__payload->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &OCTETSTRING_descr_;
    break;
  case ALT_payload:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, anytype_descr_.raw);
    encoded_length = field_payload->RAW_encode(anytype_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &anytype_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int DecodedBtpPayload::RAW_encode_negtest(const Erroneous_descriptor_t *p_err_descr, const TTCN_Typedescriptor_t& /*p_td*/, RAW_enc_tree& myleaf) const
{
  const Erroneous_values_t *err_vals = NULL;
  const Erroneous_descriptor_t *emb_descr = NULL;
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_raw__payload: {
    err_vals = p_err_descr->get_field_err_values(0);
    emb_descr = p_err_descr->get_field_emb_descr(0);
    if (err_vals && err_vals->value) {
      if (err_vals->value->raw) {
        myleaf.body.node.nodes[0] =
          new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, err_vals->value->errval->get_descriptor()->raw);
        encoded_length = err_vals->value->errval->RAW_encode_negtest_raw(*myleaf.body.node.nodes[0]);
        myleaf.body.node.nodes[0]->coding_descr = err_vals->value->errval->get_descriptor();
      } else {
        if (err_vals->value->errval) {
          if (err_vals->value->type_descr == NULL)
            TTCN_error("internal error: erroneous value typedescriptor missing");
          myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, err_vals->value->type_descr->raw);
          encoded_length = err_vals->value->errval->RAW_encode(*err_vals->value->type_descr, *myleaf.body.node.nodes[0]);
          myleaf.body.node.nodes[0]->coding_descr = err_vals->value->type_descr;
        }
      }
    } else {
      myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, OCTETSTRING_descr_.raw);
      if (emb_descr) {
        encoded_length = field_raw__payload->RAW_encode_negtest(emb_descr, OCTETSTRING_descr_, *myleaf.body.node.nodes[0]);
      } else encoded_length = field_raw__payload->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[0]);
      myleaf.body.node.nodes[0]->coding_descr = &OCTETSTRING_descr_;
    }
    break; }
  case ALT_payload: {
    err_vals = p_err_descr->get_field_err_values(1);
    emb_descr = p_err_descr->get_field_emb_descr(1);
    if (err_vals && err_vals->value) {
      if (err_vals->value->raw) {
        myleaf.body.node.nodes[1] =
          new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, err_vals->value->errval->get_descriptor()->raw);
        encoded_length = err_vals->value->errval->RAW_encode_negtest_raw(*myleaf.body.node.nodes[1]);
        myleaf.body.node.nodes[1]->coding_descr = err_vals->value->errval->get_descriptor();
      } else {
        if (err_vals->value->errval) {
          if (err_vals->value->type_descr == NULL)
            TTCN_error("internal error: erroneous value typedescriptor missing");
          myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, err_vals->value->type_descr->raw);
          encoded_length = err_vals->value->errval->RAW_encode(*err_vals->value->type_descr, *myleaf.body.node.nodes[1]);
          myleaf.body.node.nodes[1]->coding_descr = err_vals->value->type_descr;
        }
      }
    } else {
      myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, anytype_descr_.raw);
      if (emb_descr) {
        encoded_length = field_payload->RAW_encode_negtest(emb_descr, anytype_descr_, *myleaf.body.node.nodes[1]);
      } else encoded_length = field_payload->RAW_encode(anytype_descr_, *myleaf.body.node.nodes[1]);
      myleaf.body.node.nodes[1]->coding_descr = &anytype_descr_;
    }
    break; }
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int DecodedBtpPayload::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (err_descr) return JSON_encode_negtest(err_descr, p_td, p_tok);
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_raw__payload:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "raw_payload");
    enc_len += field_raw__payload->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  case ALT_payload:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload->JSON_encode(anytype_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @Btp_TypesAndValues.DecodedBtpPayload.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DecodedBtpPayload::JSON_encode_negtest(const Erroneous_descriptor_t* p_err_descr, const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  const Erroneous_values_t* err_vals = NULL;
  const Erroneous_descriptor_t* emb_descr = NULL;
  switch(union_selection) {
  case ALT_raw__payload:
    err_vals = p_err_descr->get_field_err_values(0);
    emb_descr = p_err_descr->get_field_emb_descr(0);
    if (NULL != err_vals && NULL != err_vals->value) {
      if (NULL != err_vals->value->errval) {
        if(err_vals->value->raw){
          enc_len += err_vals->value->errval->JSON_encode_negtest_raw(p_tok);
        } else {
          if (NULL == err_vals->value->type_descr) {
            TTCN_error("internal error: erroneous value typedescriptor missing");
          }
          enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "raw_payload");
          enc_len += err_vals->value->errval->JSON_encode(*err_vals->value->type_descr, p_tok);
        }
      }
    } else {
      enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "raw_payload");
      if (NULL != emb_descr) {
        enc_len += field_raw__payload->JSON_encode_negtest(emb_descr, OCTETSTRING_descr_, p_tok);
      } else {
        enc_len += field_raw__payload->JSON_encode(OCTETSTRING_descr_, p_tok);
      }
    }
    break;
  case ALT_payload:
    err_vals = p_err_descr->get_field_err_values(1);
    emb_descr = p_err_descr->get_field_emb_descr(1);
    if (NULL != err_vals && NULL != err_vals->value) {
      if (NULL != err_vals->value->errval) {
        if(err_vals->value->raw){
          enc_len += err_vals->value->errval->JSON_encode_negtest_raw(p_tok);
        } else {
          if (NULL == err_vals->value->type_descr) {
            TTCN_error("internal error: erroneous value typedescriptor missing");
          }
          enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
          enc_len += err_vals->value->errval->JSON_encode(*err_vals->value->type_descr, p_tok);
        }
      }
    } else {
      enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
      if (NULL != emb_descr) {
        enc_len += field_payload->JSON_encode_negtest(emb_descr, anytype_descr_, p_tok);
      } else {
        enc_len += field_payload->JSON_encode(anytype_descr_, p_tok);
      }
    }
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @Btp_TypesAndValues.DecodedBtpPayload.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DecodedBtpPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  size_t dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;
  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "raw_payload", name_len)) {
      int ret_val = raw__payload().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 11, "raw_payload");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += (size_t)ret_val;
      }
    } else if (0 == strncmp(fld_name, "payload", name_len)) {
      int ret_val = payload().JSON_decode(anytype_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, 7, "payload");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += (size_t)ret_val;
      }
    } else {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, (int)name_len, fld_name);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return (int)dec_len;
}

void DecodedBtpPayload_template::copy_value(const DecodedBtpPayload& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
single_value.field_raw__payload = new OCTETSTRING_template(other_value.raw__payload());
break;
case DecodedBtpPayload::ALT_payload:
single_value.field_payload = new anytype_template(other_value.payload());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Btp_TypesAndValues.DecodedBtpPayload.");
}
set_selection(SPECIFIC_VALUE);
err_descr = other_value.get_err_descr();
}

void DecodedBtpPayload_template::copy_template(const DecodedBtpPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
single_value.field_raw__payload = new OCTETSTRING_template(*other_value.single_value.field_raw__payload);
break;
case DecodedBtpPayload::ALT_payload:
single_value.field_payload = new anytype_template(*other_value.single_value.field_payload);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Btp_TypesAndValues.DecodedBtpPayload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DecodedBtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
set_selection(other_value);
err_descr = other_value.err_descr;
}

DecodedBtpPayload_template::DecodedBtpPayload_template(): err_descr(NULL)
{
}

DecodedBtpPayload_template::DecodedBtpPayload_template(template_sel other_value)
 : Base_Template(other_value), err_descr(NULL)
{
check_single_selection(other_value);
}

DecodedBtpPayload_template::DecodedBtpPayload_template(const DecodedBtpPayload& other_value)
{
copy_value(other_value);
}

DecodedBtpPayload_template::DecodedBtpPayload_template(const OPTIONAL<DecodedBtpPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecodedBtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
err_descr = NULL;
break;
default:
TTCN_error("Creating a template of union type @Btp_TypesAndValues.DecodedBtpPayload from an unbound optional field.");
}
}

DecodedBtpPayload_template::DecodedBtpPayload_template(const DecodedBtpPayload_template& other_value)
: Base_Template(){
copy_template(other_value);
}

DecodedBtpPayload_template::~DecodedBtpPayload_template()
{
clean_up();
}

void DecodedBtpPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
delete single_value.field_raw__payload;
break;
case DecodedBtpPayload::ALT_payload:
delete single_value.field_payload;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
err_descr = NULL;
return *this;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(const DecodedBtpPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(const OPTIONAL<DecodedBtpPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecodedBtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
err_descr = NULL;
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
return *this;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(const DecodedBtpPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DecodedBtpPayload_template::match(const DecodedBtpPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
DecodedBtpPayload::union_selection_type value_selection = other_value.get_selection();
if (value_selection == DecodedBtpPayload::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case DecodedBtpPayload::ALT_raw__payload:
return single_value.field_raw__payload->match(other_value.raw__payload(), legacy);
case DecodedBtpPayload::ALT_payload:
return single_value.field_payload->match(other_value.payload(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
return FALSE;
}

boolean DecodedBtpPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
return single_value.field_raw__payload->is_value();
case DecodedBtpPayload::ALT_payload:
return single_value.field_payload->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
}

DecodedBtpPayload DecodedBtpPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
DecodedBtpPayload ret_val;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
ret_val.raw__payload() = single_value.field_raw__payload->valueof();
break;
case DecodedBtpPayload::ALT_payload:
ret_val.payload() = single_value.field_payload->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
ret_val.set_err_descr(err_descr);
return ret_val;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return value_list.list_value[list_index];
}
void DecodedBtpPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DecodedBtpPayload_template[list_length];
}

OCTETSTRING_template& DecodedBtpPayload_template::raw__payload()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedBtpPayload::ALT_raw__payload) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_raw__payload = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_raw__payload = new OCTETSTRING_template;
single_value.union_selection = DecodedBtpPayload::ALT_raw__payload;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_raw__payload;
}

const OCTETSTRING_template& DecodedBtpPayload_template::raw__payload() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field raw_payload in a non-specific template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
if (single_value.union_selection != DecodedBtpPayload::ALT_raw__payload) TTCN_error("Accessing non-selected field raw_payload in a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return *single_value.field_raw__payload;
}

anytype_template& DecodedBtpPayload_template::payload()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedBtpPayload::ALT_payload) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_payload = new anytype_template(ANY_VALUE);
else single_value.field_payload = new anytype_template;
single_value.union_selection = DecodedBtpPayload::ALT_payload;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_payload;
}

const anytype_template& DecodedBtpPayload_template::payload() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field payload in a non-specific template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
if (single_value.union_selection != DecodedBtpPayload::ALT_payload) TTCN_error("Accessing non-selected field payload in a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return *single_value.field_payload;
}

boolean DecodedBtpPayload_template::ischosen(DecodedBtpPayload::union_selection_type checked_selection) const
{
if (checked_selection == DecodedBtpPayload::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Btp_TypesAndValues.DecodedBtpPayload.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == DecodedBtpPayload::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Btp_TypesAndValues.DecodedBtpPayload containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Btp_TypesAndValues.DecodedBtpPayload, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Btp_TypesAndValues.DecodedBtpPayload");
}
return FALSE;
}

void DecodedBtpPayload_template::valueofv(Base_Type* value) const { *(static_cast<DecodedBtpPayload*>(value)) = valueof(); }
void DecodedBtpPayload_template::set_value(template_sel other_value) { *this = other_value; }
void DecodedBtpPayload_template::copy_value(const Base_Type* other_value) { *this = *(static_cast<const DecodedBtpPayload*>(other_value)); }
Base_Template* DecodedBtpPayload_template::clone() const { return new DecodedBtpPayload_template(*this); }
const TTCN_Typedescriptor_t* DecodedBtpPayload_template::get_descriptor() const { return &DecodedBtpPayload_descr_; }
boolean DecodedBtpPayload_template::matchv(const Base_Type* other_value, boolean legacy) const { return match(*(static_cast<const DecodedBtpPayload*>(other_value)), legacy); }
void DecodedBtpPayload_template::log_matchv(const Base_Type* match_value, boolean legacy) const  { log_match(*(static_cast<const DecodedBtpPayload*>(match_value)), legacy); }
void DecodedBtpPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
TTCN_Logger::log_event_str("{ raw_payload := ");
single_value.field_raw__payload->log();
TTCN_Logger::log_event_str(" }");
break;
case DecodedBtpPayload::ALT_payload:
TTCN_Logger::log_event_str("{ payload := ");
single_value.field_payload->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
if (err_descr) err_descr->log();
}

void DecodedBtpPayload_template::log_match(const DecodedBtpPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".raw_payload");
single_value.field_raw__payload->log_match(match_value.raw__payload(), legacy);
} else {
TTCN_Logger::log_event_str("{ raw_payload := ");
single_value.field_raw__payload->log_match(match_value.raw__payload(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case DecodedBtpPayload::ALT_payload:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".payload");
single_value.field_payload->log_match(match_value.payload(), legacy);
} else {
TTCN_Logger::log_event_str("{ payload := ");
single_value.field_payload->log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DecodedBtpPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
single_value.field_raw__payload->encode_text(text_buf);
break;
case DecodedBtpPayload::ALT_payload:
single_value.field_payload->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Btp_TypesAndValues.DecodedBtpPayload.");
}
}

void DecodedBtpPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = DecodedBtpPayload::UNBOUND_VALUE;
DecodedBtpPayload::union_selection_type new_selection = (DecodedBtpPayload::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case DecodedBtpPayload::ALT_raw__payload:
single_value.field_raw__payload = new OCTETSTRING_template;
single_value.field_raw__payload->decode_text(text_buf);
break;
case DecodedBtpPayload::ALT_payload:
single_value.field_payload = new anytype_template;
single_value.field_payload->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Btp_TypesAndValues.DecodedBtpPayload.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DecodedBtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Btp_TypesAndValues.DecodedBtpPayload.");
}
}

boolean DecodedBtpPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DecodedBtpPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DecodedBtpPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Btp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("raw_payload", param_field) == 0) {
      raw__payload().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Btp_TypesAndValues.DecodedBtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    m_p = param.get_referenced_param();
  }
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DecodedBtpPayload_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Btp_TypesAndValues.DecodedBtpPayload");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "raw_payload")) {
      raw__payload().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "payload")) {
      payload().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Btp_TypesAndValues.DecodedBtpPayload.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Btp_TypesAndValues.DecodedBtpPayload");
  }
  is_ifpresent = param.get_ifpresent() || m_p->get_ifpresent();
}

Module_Param* DecodedBtpPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@Btp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("raw_payload", param_field) == 0) {
      return raw__payload().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `DecodedBtpPayload'", param_field);
  }
  Module_Param* m_p = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    m_p = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    m_p = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    m_p = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    m_p = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case DecodedBtpPayload::ALT_raw__payload:
      mp_field = single_value.field_raw__payload->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("raw_payload")));
      break;
    case DecodedBtpPayload::ALT_payload:
      mp_field = single_value.field_payload->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("payload")));
      break;
    default:
      break;
    }
    m_p = new Module_Param_Assignment_List();
    m_p->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      m_p = new Module_Param_List_Template();
    }
    else {
      m_p = new Module_Param_ComplementList_Template();
    }
    for (size_t i_i = 0; i_i < value_list.n_values; ++i_i) {
      m_p->add_elem(value_list.list_value[i_i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    m_p->set_ifpresent();
  }
  return m_p;
}

void DecodedBtpPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_raw__payload:
single_value.field_raw__payload->check_restriction(t_res, t_name ? t_name : "@Btp_TypesAndValues.DecodedBtpPayload");
return;
case DecodedBtpPayload::ALT_payload:
single_value.field_payload->check_restriction(t_res, t_name ? t_name : "@Btp_TypesAndValues.DecodedBtpPayload");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Btp_TypesAndValues.DecodedBtpPayload.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Btp_TypesAndValues.DecodedBtpPayload");
}

void anytype::copy_value(const anytype& other_value)
{
switch (other_value.union_selection) {
default:
TTCN_error("Assignment of an unbound union value of type @Btp_TypesAndValues.anytype.");
}
union_selection = other_value.union_selection;
err_descr = other_value.err_descr;
}

anytype::anytype(): err_descr(NULL)
{
union_selection = UNBOUND_VALUE;
}

anytype::anytype(const anytype& other_value)
: Base_Type(){
copy_value(other_value);
}

anytype::~anytype()
{
clean_up();
}

anytype& anytype::operator=(const anytype& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean anytype::operator==(const anytype& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Btp_TypesAndValues.anytype.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Btp_TypesAndValues.anytype.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
default:
return FALSE;
}
}

boolean anytype::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Btp_TypesAndValues.anytype.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Btp_TypesAndValues.anytype.");
return union_selection == checked_selection;
}

boolean anytype::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean anytype::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
default: TTCN_error("Invalid selection in union is_bound");}
}

void anytype::clean_up()
{
switch (union_selection) {
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

boolean anytype::is_equal(const Base_Type* other_value) const { return *this == *(static_cast<const anytype*>(other_value)); }
void anytype::set_value(const Base_Type* other_value) { *this = *(static_cast<const anytype*>(other_value)); }
Base_Type* anytype::clone() const { return new anytype(*this); }
const TTCN_Typedescriptor_t* anytype::get_descriptor() const { return &anytype_descr_; }
void anytype::log() const
{
switch (union_selection) {
default:
TTCN_Logger::log_event_unbound();
}
if (err_descr) err_descr->log();
}

void anytype::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@Btp_TypesAndValues.anytype'");
    }
    param.error("Field `%s' not found in union type `@Btp_TypesAndValues.anytype'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    m_p = param.get_referenced_param();
  }
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  mp_last->error("Field %s does not exist in type @Btp_TypesAndValues.anytype.", mp_last->get_id()->get_name());
}

Module_Param* anytype::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@Btp_TypesAndValues.anytype'");
    }
    TTCN_error("Field `%s' not found in union type `anytype'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  default:
    break;
  }
  Module_Param_Assignment_List* m_p = new Module_Param_Assignment_List();
  m_p->add_elem(mp_field);
  return m_p;
}

void anytype::set_implicit_omit()
{
switch (union_selection) {
default: break;
}
}

void anytype::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Btp_TypesAndValues.anytype.");
}
}

void anytype::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Btp_TypesAndValues.anytype.");
}
}

void anytype_template::copy_value(const anytype& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
default:
TTCN_error("Initializing a template with an unbound value of type @Btp_TypesAndValues.anytype.");
}
set_selection(SPECIFIC_VALUE);
err_descr = other_value.get_err_descr();
}

void anytype_template::copy_template(const anytype_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Btp_TypesAndValues.anytype.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new anytype_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Btp_TypesAndValues.anytype.");
}
set_selection(other_value);
err_descr = other_value.err_descr;
}

anytype_template::anytype_template(): err_descr(NULL)
{
}

anytype_template::anytype_template(template_sel other_value)
 : Base_Template(other_value), err_descr(NULL)
{
check_single_selection(other_value);
}

anytype_template::anytype_template(const anytype& other_value)
{
copy_value(other_value);
}

anytype_template::anytype_template(const OPTIONAL<anytype>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const anytype&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
err_descr = NULL;
break;
default:
TTCN_error("Creating a template of union type @Btp_TypesAndValues.anytype from an unbound optional field.");
}
}

anytype_template::anytype_template(const anytype_template& other_value)
: Base_Template(){
copy_template(other_value);
}

anytype_template::~anytype_template()
{
clean_up();
}

void anytype_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

anytype_template& anytype_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
err_descr = NULL;
return *this;
}

anytype_template& anytype_template::operator=(const anytype& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

anytype_template& anytype_template::operator=(const OPTIONAL<anytype>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const anytype&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
err_descr = NULL;
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Btp_TypesAndValues.anytype.");
}
return *this;
}

anytype_template& anytype_template::operator=(const anytype_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean anytype_template::match(const anytype& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
anytype::union_selection_type value_selection = other_value.get_selection();
if (value_selection == anytype::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Btp_TypesAndValues.anytype.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Btp_TypesAndValues.anytype.");
}
return FALSE;
}

boolean anytype_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Btp_TypesAndValues.anytype.");
}
}

anytype anytype_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Btp_TypesAndValues.anytype.");
anytype ret_val;
switch (single_value.union_selection) {
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Btp_TypesAndValues.anytype.");
}
ret_val.set_err_descr(err_descr);
return ret_val;
}

anytype_template& anytype_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Btp_TypesAndValues.anytype.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Btp_TypesAndValues.anytype.");
return value_list.list_value[list_index];
}
void anytype_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Btp_TypesAndValues.anytype.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new anytype_template[list_length];
}

boolean anytype_template::ischosen(anytype::union_selection_type checked_selection) const
{
if (checked_selection == anytype::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Btp_TypesAndValues.anytype.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == anytype::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Btp_TypesAndValues.anytype.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Btp_TypesAndValues.anytype containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Btp_TypesAndValues.anytype, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Btp_TypesAndValues.anytype");
}
return FALSE;
}

void anytype_template::valueofv(Base_Type* value) const { *(static_cast<anytype*>(value)) = valueof(); }
void anytype_template::set_value(template_sel other_value) { *this = other_value; }
void anytype_template::copy_value(const Base_Type* other_value) { *this = *(static_cast<const anytype*>(other_value)); }
Base_Template* anytype_template::clone() const { return new anytype_template(*this); }
const TTCN_Typedescriptor_t* anytype_template::get_descriptor() const { return &anytype_descr_; }
boolean anytype_template::matchv(const Base_Type* other_value, boolean legacy) const { return match(*(static_cast<const anytype*>(other_value)), legacy); }
void anytype_template::log_matchv(const Base_Type* match_value, boolean legacy) const  { log_match(*(static_cast<const anytype*>(match_value)), legacy); }
void anytype_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
if (err_descr) err_descr->log();
}

void anytype_template::log_match(const anytype& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void anytype_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Btp_TypesAndValues.anytype.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Btp_TypesAndValues.anytype.");
}
}

void anytype_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = anytype::UNBOUND_VALUE;
anytype::union_selection_type new_selection = (anytype::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Btp_TypesAndValues.anytype.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new anytype_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Btp_TypesAndValues.anytype.");
}
}

boolean anytype_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean anytype_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void anytype_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Btp_TypesAndValues.anytype'");
    }
    param.error("Field `%s' not found in union template type `@Btp_TypesAndValues.anytype'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    m_p = param.get_referenced_param();
  }
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    anytype_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Btp_TypesAndValues.anytype");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    mp_last->error("Field %s does not exist in type @Btp_TypesAndValues.anytype.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Btp_TypesAndValues.anytype");
  }
  is_ifpresent = param.get_ifpresent() || m_p->get_ifpresent();
}

Module_Param* anytype_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@Btp_TypesAndValues.anytype'");
    }
    TTCN_error("Field `%s' not found in union type `anytype'", param_field);
  }
  Module_Param* m_p = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    m_p = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    m_p = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    m_p = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    m_p = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    default:
      break;
    }
    m_p = new Module_Param_Assignment_List();
    m_p->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      m_p = new Module_Param_List_Template();
    }
    else {
      m_p = new Module_Param_ComplementList_Template();
    }
    for (size_t i_i = 0; i_i < value_list.n_values; ++i_i) {
      m_p->add_elem(value_list.list_value[i_i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    m_p->set_ifpresent();
  }
  return m_p;
}

void anytype_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Btp_TypesAndValues.anytype.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Btp_TypesAndValues.anytype");
}

void Frame::init_vec() { fld_vec[0]=&field_data__length; fld_vec[1]=&field_data__stream;  }

Frame::Frame() : Record_Type() { init_vec(); }

Frame::Frame(const Frame& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_data__length.is_bound() )
  field_data__length = other_value.field_data__length;
if (other_value.field_data__stream.is_bound() )
  field_data__stream = other_value.field_data__stream;
init_vec();
}

Frame::Frame(const OCTETSTRING& par_data__length,
    const OCTETSTRING& par_data__stream) : field_data__length(par_data__length),
    field_data__stream(par_data__stream)
{
init_vec();
}

const TTCN_Typedescriptor_t* Frame::get_descriptor() const { return &Frame_descr_; }
const TTCN_Typedescriptor_t* Frame::fld_descriptors[] = { &Oct2_descr_, &OCTETSTRING_descr_ };
const TTCN_Typedescriptor_t* Frame::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* Frame::fld_names[] = { "data_length", "data_stream" };
const char* Frame::fld_name(int p_index) const { return fld_names[p_index]; }

void Frame_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 2;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new OCTETSTRING_template(ANY_VALUE) : new OCTETSTRING_template;
single_value.value_elements[1] = was_any ? new OCTETSTRING_template(ANY_VALUE) : new OCTETSTRING_template;
}
}

Frame_template& Frame_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Frame_template& Frame_template::operator=(const Frame& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

Frame_template& Frame_template::operator=(const OPTIONAL<Frame>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

Frame_template& Frame_template::operator=(const Frame_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

Frame Frame_template::valueof() const
{
Frame ret_val;
valueofv(&ret_val);
return ret_val;
}

OCTETSTRING_template& Frame_template::data__length() { return *(static_cast<OCTETSTRING_template*>(get_at(0))); }
const OCTETSTRING_template& Frame_template::data__length() const { return *(static_cast<const OCTETSTRING_template*>(get_at(0))); }
OCTETSTRING_template& Frame_template::data__stream() { return *(static_cast<OCTETSTRING_template*>(get_at(1))); }
const OCTETSTRING_template& Frame_template::data__stream() const { return *(static_cast<const OCTETSTRING_template*>(get_at(1))); }
const TTCN_Typedescriptor_t* Frame_template::get_descriptor() const { return &Frame_descr_; }
const char* Frame_template::fld_name(int p_index) const { return Frame::fld_names[p_index]; }

/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../ttcn/Btp_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "Btp_TypesAndValues");
current_location.update_lineno(3);
/* ../ttcn/Btp_TypesAndValues.ttcn, line 3 */
const_c__uInt16Max = 65535;
}


} /* end of namespace */
