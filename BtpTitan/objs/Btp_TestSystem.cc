// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for Yann Garcia (yann@Ubuntu64) on Tue Feb 28 11:22:01 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "Btp_TestSystem.hh"

namespace Btp__TestSystem {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x2e, 0x13, 0x40, 0xfc, 0x21, 0xeb, 0x39, 0x74, 0xe2, 0xca, 0xa1, 0x7a, 0xa8, 0x70, 0xc9, 0x8a };

/* Global variable definitions */

const TTCN_RAWdescriptor_t BtpInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpInd
const TTCN_JSONdescriptor_t BtpInd_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpInd_descr_ = { "@Btp_TestSystem.BtpInd", NULL, &BtpInd_raw_, NULL, NULL, &BtpInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpReq_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
// No XER for BtpReq
const TTCN_JSONdescriptor_t BtpReq_json_ = { FALSE, NULL, FALSE, NULL, FALSE };
const TTCN_Typedescriptor_t BtpReq_descr_ = { "@Btp_TestSystem.BtpReq", NULL, &BtpReq_raw_, NULL, NULL, &BtpReq_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ItsBtpSystem_descr_ = COMPONENT_descr_;
BtpPort ItsBtpSystem_component_btpPort("btpPort");
const TTCN_Typedescriptor_t& ItsBtp_descr_ = COMPONENT_descr_;
BtpPort ItsBtp_component_btpPort("btpPort");
TTCN_Module module_object("Btp_TestSystem", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, init_comp_type, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_2);

/* Member functions of C++ classes */

void BtpPort_BASE::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void BtpPort_BASE::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

BtpPort_BASE::BtpPort_BASE(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

BtpPort_BASE::~BtpPort_BASE()
{
clear_queue();
}

void BtpPort_BASE::send(const BtpReq& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @Btp_TestSystem.BtpReq : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) {
(void)get_default_destination();
outgoing_send(send_par);
}
else {
Text_Buf text_buf;
prepare_message(text_buf, "@Btp_TestSystem.BtpReq");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void BtpPort_BASE::send(const BtpReq& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void BtpPort_BASE::send(const BtpReq_template& send_par, const COMPONENT& destination_component)
{
const BtpReq& send_par_value = BtpReq(send_par.valueof());
send(send_par_value, destination_component);
}

void BtpPort_BASE::send(const BtpReq_template& send_par)
{
const BtpReq& send_par_value = BtpReq(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status BtpPort_BASE::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @Btp_TestSystem.BtpInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status BtpPort_BASE::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @Btp_TestSystem.BtpInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status BtpPort_BASE::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @Btp_TestSystem.BtpInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status BtpPort_BASE::receive(const BtpInd_template& value_template, Value_Redirect_Interface *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
if (value_template.get_selection() == ANY_OR_OMIT) TTCN_error("Receive operation using '*' as matching template");
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @Btp_TestSystem.BtpInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_redirect != NULL) {
value_redirect->set_values(my_head->message_0);
}
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @Btp_TestSystem.BtpInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status BtpPort_BASE::check_receive(const BtpInd_template& value_template, Value_Redirect_Interface *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
if (value_template.get_selection() == ANY_OR_OMIT) TTCN_error("Check-receive operation using '*' as matching template");
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @Btp_TestSystem.BtpInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_redirect != NULL) {
value_redirect->set_values(my_head->message_0);
}
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @Btp_TestSystem.BtpInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status BtpPort_BASE::trigger(const BtpInd_template& value_template, Value_Redirect_Interface *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
if (value_template.get_selection() == ANY_OR_OMIT) TTCN_error("Trigger operation using '*' as matching template");
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @Btp_TestSystem.BtpInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_redirect != NULL) {
value_redirect->set_values(my_head->message_0);
}
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @Btp_TestSystem.BtpInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void BtpPort_BASE::incoming_message(const BtpInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @Btp_TestSystem.BtpInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new BtpInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean BtpPort_BASE::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@Btp_TestSystem.BtpInd")) {
BtpInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

void BtpInd::init_vec() { fld_vec[0]=&field_msgIn;  }

BtpInd::BtpInd() : Record_Type() { init_vec(); }

BtpInd::BtpInd(const BtpInd& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_msgIn.is_bound() )
  field_msgIn = other_value.field_msgIn;
init_vec();
}

BtpInd::BtpInd(const Btp__TypesAndValues::BtpPacket& par_msgIn) : field_msgIn(par_msgIn)
{
init_vec();
}

const TTCN_Typedescriptor_t* BtpInd::get_descriptor() const { return &BtpInd_descr_; }
const TTCN_Typedescriptor_t* BtpInd::fld_descriptors[] = { &Btp__TypesAndValues::BtpPacket_descr_ };
const TTCN_Typedescriptor_t* BtpInd::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* BtpInd::fld_names[] = { "msgIn" };
const char* BtpInd::fld_name(int p_index) const { return fld_names[p_index]; }

void BtpInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 1;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new Btp__TypesAndValues::BtpPacket_template(ANY_VALUE) : new Btp__TypesAndValues::BtpPacket_template;
}
}

BtpInd_template& BtpInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpInd_template& BtpInd_template::operator=(const BtpInd& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

BtpInd_template& BtpInd_template::operator=(const OPTIONAL<BtpInd>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

BtpInd_template& BtpInd_template::operator=(const BtpInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

BtpInd BtpInd_template::valueof() const
{
BtpInd ret_val;
valueofv(&ret_val);
return ret_val;
}

Btp__TypesAndValues::BtpPacket_template& BtpInd_template::msgIn() { return *(static_cast<Btp__TypesAndValues::BtpPacket_template*>(get_at(0))); }
const Btp__TypesAndValues::BtpPacket_template& BtpInd_template::msgIn() const { return *(static_cast<const Btp__TypesAndValues::BtpPacket_template*>(get_at(0))); }
const TTCN_Typedescriptor_t* BtpInd_template::get_descriptor() const { return &BtpInd_descr_; }
const char* BtpInd_template::fld_name(int p_index) const { return BtpInd::fld_names[p_index]; }
void BtpReq::init_vec() { fld_vec[0]=&field_msgOut;  }

BtpReq::BtpReq() : Record_Type() { init_vec(); }

BtpReq::BtpReq(const BtpReq& other_value) : Record_Type(other_value)
{
  if(!other_value.is_bound()) TTCN_error("Copying an unbound record/set value.");
if (other_value.field_msgOut.is_bound() )
  field_msgOut = other_value.field_msgOut;
init_vec();
}

BtpReq::BtpReq(const Btp__TypesAndValues::BtpPacket& par_msgOut) : field_msgOut(par_msgOut)
{
init_vec();
}

const TTCN_Typedescriptor_t* BtpReq::get_descriptor() const { return &BtpReq_descr_; }
const TTCN_Typedescriptor_t* BtpReq::fld_descriptors[] = { &Btp__TypesAndValues::BtpPacket_descr_ };
const TTCN_Typedescriptor_t* BtpReq::fld_descr(int p_index) const { return fld_descriptors[p_index]; }

const char* BtpReq::fld_names[] = { "msgOut" };
const char* BtpReq::fld_name(int p_index) const { return fld_names[p_index]; }

void BtpReq_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
boolean was_any = (template_selection == ANY_VALUE || template_selection == ANY_OR_OMIT);
clean_up();
single_value.n_elements = 1;
single_value.value_elements = (Base_Template**)allocate_pointers(single_value.n_elements);
set_selection(SPECIFIC_VALUE);
single_value.value_elements[0] = was_any ? new Btp__TypesAndValues::BtpPacket_template(ANY_VALUE) : new Btp__TypesAndValues::BtpPacket_template;
}
}

BtpReq_template& BtpReq_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpReq_template& BtpReq_template::operator=(const BtpReq& other_value)
{
clean_up();
copy_value(&other_value);
return *this;
}

BtpReq_template& BtpReq_template::operator=(const OPTIONAL<BtpReq>& other_value)
{
clean_up();
copy_optional(&other_value);
return *this;
}

BtpReq_template& BtpReq_template::operator=(const BtpReq_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

BtpReq BtpReq_template::valueof() const
{
BtpReq ret_val;
valueofv(&ret_val);
return ret_val;
}

Btp__TypesAndValues::BtpPacket_template& BtpReq_template::msgOut() { return *(static_cast<Btp__TypesAndValues::BtpPacket_template*>(get_at(0))); }
const Btp__TypesAndValues::BtpPacket_template& BtpReq_template::msgOut() const { return *(static_cast<const Btp__TypesAndValues::BtpPacket_template*>(get_at(0))); }
const TTCN_Typedescriptor_t* BtpReq_template::get_descriptor() const { return &BtpReq_descr_; }
const char* BtpReq_template::fld_name(int p_index) const { return BtpReq::fld_names[p_index]; }

/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../ttcn/Btp_TestSystem.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "Btp_TestSystem");
Btp__TypesAndValues::module_object.pre_init_module();
}

static void post_init_module()
{
TTCN_Location current_location("../ttcn/Btp_TestSystem.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "Btp_TestSystem");
Btp__TypesAndValues::module_object.post_init_module();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "ItsBtpSystem")) {
ItsBtpSystem_component_btpPort.activate_port();
return TRUE;
} else if (!strcmp(component_type, "ItsBtp")) {
ItsBtp_component_btpPort.activate_port();
return TRUE;
} else return FALSE;
}


} /* end of namespace */
